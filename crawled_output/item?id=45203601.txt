The rules behing Rust functions | Hacker NewsHacker Newsnew | past | comments | ask | show | jobs | submitloginThe rules behing Rust functions (cuongle.dev)48 points by gidellav 8 hours ago
| hide | past | favorite | 11 comments
cratermoon 3 hours ago
| next [–]
To the author of this blog post: please write the code examples as syntax-colored text,
and definitely not as images.
I'd love to copy the code and paste it into the Rust playground or godbolt,
so I can see exactly what the compiler does and how the code behaves.
I can't do that with screenshots of code.replyCamJN 2 minutes ago
| parent | next [–]
You can on Apple’s OSs, and some googling suggests you can do it on windows too if you save the image and open in the image viewer. Therefore I’d be surprised if you couldn’t get it working on various linux distros too...replyfulafel 4 hours ago
| prev | next [–]
Would be interesting to see a comparison with GCC's C closures[1].[1] https://gcc.gnu.org/onlinedocs/gcc/Nested-Functions.htmlreplymeindnoch 5 hours ago
| prev [9 more]
[flagged]kccqzy 5 hours ago
| parent | next [–]
But the difference between a closure and a function pointer is essential complexity, not accidental complexity.If a language were to provide only closures and not function pointers, it would not be low level enough to interface with C code and C ABI. That's definitely not what Rust needs.replyPhantomHour 4 hours ago
| root | parent | next [–]
Whether or not it's "essential" is kind of irrelevant for the ergonomics; Languages do exist that provide only closures. (And yes, the likes of Java do struggle a bit with function pointer ffi) Similarly, "we need this because low level" has never made C++ more tolerable.The thing about rust is that it's complexity is self-contained and follows established rules. If one understands data ownership, one only needs to be told what a closure is for all these edge cases and problems to make sense.Contrast the complexities of JavaScript, many of which still boil down to "Some doofus 30 years ago didn't do any homework and made bad design decisions for type coercion". Just "fuck you, go memorize these behaviours".replyYgg2 4 hours ago
| root | parent | next [–]
> Whether or not it's "essential" is kind of irrelevant for the ergonomics;The thing about essential complexity is you always pay for it. Either during compile or execution. Java has concept of thread safe but doesn't track it via types. You still need to take it into account when working with it.replyfulafel 4 hours ago
| root | parent | prev | next [–]
Nah, lots of higher level languages interface with C.replysbinder 3 hours ago
| root | parent | next [–]
by dynamically allocating FFI trampolines, which add their own performance and lifetime issues that would be unacceptable for Rust.replyxondono 4 hours ago
| parent | prev | next [–]
This has been in Rust since before the 1.0 release.Also, you can’t converge to a diverging number, for Rust to get close to C++’s level of complexity, the C++ WG would have to stop with their garbage.replyozgrakkurt 5 hours ago
| parent | prev | next [–]
Really can’t see how it could be made simpler. Function pointer can’t be a closure because it means something different. You can pass pointers different functions without having multiple versions of the function you are calling. Closures have a unique type and they require you to use generics.replykibwen 5 hours ago
| parent | prev [–]
What? All of this stuff has been in the language since 2014 at least. If you want stack-allocated closures which can safely close over references, this is the machinery you need. Rust's implementation is the state of the art.reply
Guidelines | FAQ | Lists | API | Security | Legal | Apply to YC | Contact
Search:
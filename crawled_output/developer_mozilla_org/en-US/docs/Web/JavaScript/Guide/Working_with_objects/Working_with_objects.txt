Working with objects - JavaScript | MDN
Skip to main content
Skip to search
MDN
HTML
HTML: Markup language
HTML reference
Elements
Global attributes
Attributes
See allâ¦
HTML guides
Responsive images
HTML cheatsheet
Date & time formats
See allâ¦
Markup languages
SVG
MathML
XML
CSS
CSS: Styling language
CSS reference
Properties
Selectors
At-rules
Values & units
See allâ¦
CSS guides
Box model
Animations
Flexbox
Colors
See allâ¦
Layout cookbook
Column layouts
Centering an element
Card component
See allâ¦
JavaScript
JS
JavaScript: Scripting language
JS reference
Standard built-in objects
Expressions & operators
Statements & declarations
Functions
See allâ¦
JS guides
Control flow & error handing
Loops and iteration
Working with objects
Using classes
See allâ¦
Web APIs
Web APIs: Programming interfaces
Web API reference
File system API
Fetch API
Geolocation API
HTML DOM API
Push API
Service worker API
See allâ¦
Web API guides
Using the Web animation API
Using the Fetch API
Working with the History API
Using the Web speech API
Using web workers
All
All web technology
Technologies
Accessibility
HTTP
URI
Web extensions
WebAssembly
WebDriver
See allâ¦
Topics
Media
Performance
Privacy
Security
Progressive web apps
Learn
Learn web development
Frontend developer course
Getting started
Common questions
Curriculum
Learn HTML
Introduction to HTML
Getting started with HTML
Learn CSS
What is CSS
Getting started with CSS
Learn JavaScript
How to use data attributes
Add JavaScript to your web page
Tools
Discover our tools
Playground
HTTP Observatory
Border-image generator
Border-radius generator
Box-shadow generator
Color mixer
Color picker
Shape generator
About
Get to know MDN better
About MDN
Advertise with us
Community
MDN on GitHub
Blog
Web
JavaScript
Guide
Working with objects
Working with objects
Previous
Next
JavaScript is designed on an object-based paradigm. An object is a collection of properties, and a property is an association between a name (or key) and a value. A property's value can be a function, in which case the property is known as a method.
Objects in JavaScript, just as in many other programming languages, can be compared to objects in real life. In JavaScript, an object is a standalone entity, with properties and type. Compare it with a cup, for example. A cup is an object, with properties. A cup has a color, a design, weight, a material it is made of, etc. The same way, JavaScript objects can have properties, which define their characteristics.
In addition to objects that are predefined in the browser, you can define your own objects. This chapter describes how to use objects, properties, and methods, and how to create your own objects.
In this article
Creating new objectsObjects and propertiesInheritanceDefining methodsDefining getters and settersComparing objectsSee also
Creating new objects
You can create an object using an object initializer. Alternatively, you can first create a constructor function and then instantiate an object by invoking that function with the new operator.
Using object initializers
Object initializers are also called object literals. "Object initializer" is consistent with the terminology used by C++.
The syntax for an object using an object initializer is:
jsconst obj = {
property1: value1, // property name may be an identifier
2: value2, // or a number
"property n": value3, // or a string
};
Each property name before colons is an identifier (either a name, a number, or a string literal), and each valueN is an expression whose value is assigned to the property name. The property name can also be an expression; computed keys need to be wrapped in square brackets. The object initializer reference contains a more detailed explanation of the syntax.
In this example, the newly created object is assigned to a variable obj â this is optional. If you do not need to refer to this object elsewhere, you do not need to assign it to a variable. (Note that you may need to wrap the object literal in parentheses if the object appears where a statement is expected, so as not to have the literal be confused with a block statement.)
Object initializers are expressions, and each object initializer results in a new object being created whenever the statement in which it appears is executed. Identical object initializers create distinct objects that do not compare to each other as equal.
The following statement creates an object and assigns it to the variable x if and only if the expression cond is true:
jslet x;
if (cond) {
x = { greeting: "hi there" };
}
The following example creates myHonda with three properties. Note that the engine property is also an object with its own properties.
jsconst myHonda = {
color: "red",
wheels: 4,
engine: { cylinders: 4, size: 2.2 },
};
Objects created with initializers are called plain objects, because they are instances of Object, but not any other object type. Some object types have special initializer syntaxes â for example, array initializers and regex literals.
Using a constructor function
Alternatively, you can create an object with these two steps:
Define the object type by writing a constructor function. There is a strong convention, with good reason, to use a capital initial letter.
Create an instance of the object with new.
To define an object type, create a function for the object type that specifies its name, properties, and methods. For example, suppose you want to create an object type for cars. You want this type of object to be called Car, and you want it to have properties for make, model, and year. To do this, you would write the following function:
jsfunction Car(make, model, year) {
this.make = make;
this.model = model;
this.year = year;
}
Notice the use of this to assign values to the object's properties based on the values passed to the function.
Now you can create an object called myCar as follows:
jsconst myCar = new Car("Eagle", "Talon TSi", 1993);
This statement creates myCar and assigns it the specified values for its properties. Then the value of myCar.make is the string "Eagle", myCar.model is the string "Talon TSi", myCar.year is the integer 1993, and so on. The order of arguments and parameters should be the same.
You can create any number of Car objects by calls to new. For example,
jsconst randCar = new Car("Nissan", "300ZX", 1992);
const kenCar = new Car("Mazda", "Miata", 1990);
An object can have a property that is itself another object. For example, suppose you define an object called Person as follows:
jsfunction Person(name, age, sex) {
this.name = name;
this.age = age;
this.sex = sex;
}
and then instantiate two new Person objects as follows:
jsconst rand = new Person("Rand McKinnon", 33, "M");
const ken = new Person("Ken Jones", 39, "M");
Then, you can rewrite the definition of Car to include an owner property that takes a Person object, as follows:
jsfunction Car(make, model, year, owner) {
this.make = make;
this.model = model;
this.year = year;
this.owner = owner;
}
To instantiate the new objects, you then use the following:
jsconst car1 = new Car("Eagle", "Talon TSi", 1993, rand);
const car2 = new Car("Nissan", "300ZX", 1992, ken);
Notice that instead of passing a literal string or integer value when creating the new objects, the above statements pass the objects rand and ken as the arguments for the owners. Then if you want to find out the name of the owner of car2, you can access the following property:
jscar2.owner.name;
You can always add a property to a previously defined object. For example, the statement
jscar1.color = "black";
adds a property color to car1, and assigns it a value of "black". However, this does not affect any other objects. To add the new property to all objects of the same type, you have to add the property to the definition of the Car object type.
You can also use the class syntax instead of the function syntax to define a constructor function. For more information, see the class guide.
Using the Object.create() method
Objects can also be created using the Object.create() method. This method can be very useful, because it allows you to choose the prototype object for the object you want to create, without having to define a constructor function.
js// Animal properties and method encapsulation
const Animal = {
type: "Invertebrates", // Default value of properties
displayType() {
// Method which will display type of Animal
console.log(this.type);
},
};
// Create new animal type called `animal`
const animal = Object.create(Animal);
animal.displayType(); // Logs: Invertebrates
// Create new animal type called fish
const fish = Object.create(Animal);
fish.type = "Fishes";
fish.displayType(); // Logs: Fishes
Objects and properties
A JavaScript object has properties associated with it. Object properties are basically the same as variables, except that they are associated with objects, not scopes. The properties of an object define the characteristics of the object.
For example, this example creates an object named myCar, with properties named make, model, and year, with their values set to "Ford", "Mustang", and 1969:
jsconst myCar = {
make: "Ford",
model: "Mustang",
year: 1969,
};
Like JavaScript variables, property names are case sensitive. Property names can only be strings or Symbols â all keys are converted to strings unless they are Symbols. Array indices are, in fact, properties with string keys that contain integers.
Accessing properties
You can access a property of an object by its property name. Property accessors come in two syntaxes: dot notation and bracket notation. For example, you could access the properties of the myCar object as follows:
js// Dot notation
myCar.make = "Ford";
myCar.model = "Mustang";
myCar.year = 1969;
// Bracket notation
myCar["make"] = "Ford";
myCar["model"] = "Mustang";
myCar["year"] = 1969;
An object property name can be any JavaScript string or symbol, including an empty string. However, you cannot use dot notation to access a property whose name is not a valid JavaScript identifier. For example, a property name that has a space or a hyphen, that starts with a number, or that is held inside a variable can only be accessed using the bracket notation. This notation is also very useful when property names are to be dynamically determined, i.e., not determinable until runtime. Examples are as follows:
jsconst myObj = {};
const str = "myString";
const rand = Math.random();
const anotherObj = {};
// Create additional properties on myObj
myObj.type = "Dot syntax for a key named type";
myObj["date created"] = "This key has a space";
myObj[str] = "This key is in variable str";
myObj[rand] = "A random number is the key here";
myObj[anotherObj] = "This key is object anotherObj";
myObj[""] = "This key is an empty string";
console.log(myObj);
// {
//
type: 'Dot syntax for a key named type',
//
'date created': 'This key has a space',
//
myString: 'This key is in variable str',
//
'0.6398914448618778': 'A random number is the key here',
//
'[object Object]': 'This key is object anotherObj',
//
'': 'This key is an empty string'
// }
console.log(myObj.myString); // 'This key is in variable str'
In the above code, the key anotherObj is an object, which is neither a string nor a symbol. When it is added to the myObj, JavaScript calls the toString() method of anotherObj, and use the resulting string as the new key.
You can also access properties with a string value stored in a variable. The variable must be passed in bracket notation. In the example above, the variable str held "myString" and it is "myString" that is the property name. Therefore, myObj.str will return as undefined.
jsstr = "myString";
myObj[str] = "This key is in variable str";
console.log(myObj.str); // undefined
console.log(myObj[str]); // 'This key is in variable str'
console.log(myObj.myString); // 'This key is in variable str'
This allows accessing any property as determined at runtime:
jslet propertyName = "make";
myCar[propertyName] = "Ford";
// access different properties by changing the contents of the variable
propertyName = "model";
myCar[propertyName] = "Mustang";
console.log(myCar); // { make: 'Ford', model: 'Mustang' }
However, beware of using square brackets to access properties whose names are given by external input. This may make your code susceptible to object injection attacks.
Nonexistent properties of an object have value undefined (and not null).
jsmyCar.nonexistentProperty; // undefined
Enumerating properties
There are three native ways to list/traverse object properties:
for...in loops. This method traverses all of the enumerable string properties of an object as well as its prototype chain.
Object.keys(). This method returns an array with only the enumerable own string property names ("keys") in the object myObj, but not those in the prototype chain.
Object.getOwnPropertyNames(). This method returns an array containing all the own string property names in the object myObj, regardless of if they are enumerable or not.
You can use the bracket notation with for...in to iterate over all the enumerable properties of an object. To illustrate how this works, the following function displays the properties of the object when you pass the object and the object's name as arguments to the function:
jsfunction showProps(obj, objName) {
let result = "";
for (const i in obj) {
// Object.hasOwn() is used to exclude properties from the object's
// prototype chain and only show "own properties"
if (Object.hasOwn(obj, i)) {
result += `${objName}.${i} = ${obj[i]}\n`;
}
}
console.log(result);
}
The term "own property" refers to the properties of the object, but excluding those of the prototype chain. So, the function call showProps(myCar, 'myCar') would print the following:
myCar.make = Ford
myCar.model = Mustang
myCar.year = 1969
The above is equivalent to:
jsfunction showProps(obj, objName) {
let result = "";
Object.keys(obj).forEach((i) => {
result += `${objName}.${i} = ${obj[i]}\n`;
});
console.log(result);
}
There is no native way to list all inherited properties including non-enumerable ones. However, this can be achieved with the following function:
jsfunction listAllProperties(myObj) {
let objectToInspect = myObj;
let result = [];
while (objectToInspect !== null) {
result = result.concat(Object.getOwnPropertyNames(objectToInspect));
objectToInspect = Object.getPrototypeOf(objectToInspect);
}
return result;
}
For more information, see Enumerability and ownership of properties.
Deleting properties
You can remove a non-inherited property using the delete operator. The following code shows how to remove a property.
js// Creates a new object, myObj, with two properties, a and b.
const myObj = { a: 5, b: 12 };
// Removes the a property, leaving myObj with only the b property.
delete myObj.a;
console.log("a" in myObj); // false
Inheritance
All objects in JavaScript inherit from at least one other object. The object being inherited from is known as the prototype, and the inherited properties can be found in the prototype object of the constructor. See Inheritance and the prototype chain for more information.
Defining properties for all objects of one type
You can add a property to all objects created through a certain constructor using the prototype property. This defines a property that is shared by all objects of the specified type, rather than by just one instance of the object. The following code adds a color property to all objects of type Car, and then reads the property's value from an instance car1.
jsCar.prototype.color = "red";
console.log(car1.color); // "red"
Defining methods
A method is a function associated with an object, or, put differently, a method is a property of an object that is a function. Methods are defined the way normal functions are defined, except that they have to be assigned as the property of an object. See also method definitions for more details. An example is:
jsobjectName.methodName = functionName;
const myObj = {
myMethod: function (params) {
// do something
},
// this works too!
myOtherMethod(params) {
// do something else
},
};
where objectName is an existing object, methodName is the name you are assigning to the method, and functionName is the name of the function.
You can then call the method in the context of the object as follows:
jsobjectName.methodName(params);
Methods are typically defined on the prototype object of the constructor, so that all objects of the same type share the same method. For example, you can define a function that formats and displays the properties of the previously-defined Car objects.
jsCar.prototype.displayCar = function () {
const result = `A Beautiful ${this.year} ${this.make} ${this.model}`;
console.log(result);
};
Notice the use of this to refer to the object to which the method belongs. Then you can call the displayCar method for each of the objects as follows:
jscar1.displayCar();
car2.displayCar();
Using this for object references
JavaScript has a special keyword, this, that you can use within a method to refer to the current object. For example, suppose you have 2 objects, Manager and Intern. Each object has its own name, age and job. In the function sayHi(), notice the use of this.name. When added to the 2 objects, the same function will print the message with the name of the respective object it's attached to.
jsconst Manager = {
name: "Karina",
age: 27,
job: "Software Engineer",
};
const Intern = {
name: "Tyrone",
age: 21,
job: "Software Engineer Intern",
};
function sayHi() {
console.log(`Hello, my name is ${this.name}`);
}
// add sayHi function to both objects
Manager.sayHi = sayHi;
Intern.sayHi = sayHi;
Manager.sayHi(); // Hello, my name is Karina
Intern.sayHi(); // Hello, my name is Tyrone
this is a "hidden parameter" of a function call that's passed in by specifying the object before the function that was called. For example, in Manager.sayHi(), this is the Manager object, because Manager comes before the function sayHi(). If you access the same function from another object, this will change as well. If you use other methods to call the function, like Function.prototype.call() or Reflect.apply(), you can explicitly pass the value of this as an argument.
Defining getters and setters
A getter is a function associated with a property that gets the value of a specific property. A setter is a function associated with a property that sets the value of a specific property. Together, they can indirectly represent the value of a property.
Getters and setters can be either
defined within object initializers, or
added later to any existing object.
Within object initializers, getters and setters are defined like regular methods, but prefixed with the keywords get or set. The getter method must not expect a parameter, while the setter method expects exactly one parameter (the new value to set). For instance:
jsconst myObj = {
a: 7,
get b() {
return this.a + 1;
},
set c(x) {
this.a = x / 2;
},
};
console.log(myObj.a); // 7
console.log(myObj.b); // 8, returned from the get b() method
myObj.c = 50; // Calls the set c(x) method
console.log(myObj.a); // 25
The myObj object's properties are:
myObj.a â a number
myObj.b â a getter that returns myObj.a plus 1
myObj.c â a setter that sets the value of myObj.a to half of the value myObj.c is being set to
Getters and setters can also be added to an object at any time after creation using the Object.defineProperties() method. This method's first parameter is the object on which you want to define the getter or setter. The second parameter is an object whose property names are the getter or setter names, and whose property values are objects for defining the getter or setter functions. Here's an example that defines the same getter and setter used in the previous example:
jsconst myObj = { a: 0 };
Object.defineProperties(myObj, {
b: {
get() {
return this.a + 1;
},
},
c: {
set(x) {
this.a = x / 2;
},
},
});
myObj.c = 10; // Runs the setter, which assigns 10 / 2 (5) to the 'a' property
console.log(myObj.b); // Runs the getter, which yields a + 1 or 6
Which of the two forms to choose depends on your programming style and task at hand. If you can change the definition of the original object, you will probably define getters and setters through the original initializer. This form is more compact and natural. However, if you need to add getters and setters later â maybe because you did not write the particular object â then the second form is the only possible form. The second form better represents the dynamic nature of JavaScript, but it can make the code hard to read and understand.
Comparing objects
In JavaScript, objects are a reference type. Two distinct objects are never equal, even if they have the same properties. Only comparing the same object reference with itself yields true.
js// Two variables, two distinct objects with the same properties
const fruit = { name: "apple" };
const anotherFruit = { name: "apple" };
fruit == anotherFruit; // return false
fruit === anotherFruit; // return false
js// Two variables, a single object
const fruit = { name: "apple" };
const anotherFruit = fruit; // Assign fruit object reference to anotherFruit
// Here fruit and anotherFruit are pointing to same object
fruit == anotherFruit; // return true
fruit === anotherFruit; // return true
fruit.name = "grape";
console.log(anotherFruit); // { name: "grape" }; not { name: "apple" }
For more information about comparison operators, see equality operators.
See also
Inheritance and the prototype chain
Classes
Previous
Next
Help improve MDN
Learn how to contribute
This page was last modified on â¨Aug 27, 2025â© by MDN contributors.
View this page on GitHub â¢ Report a problem with this content
JavaScriptTutorials and guidesBeginner's tutorialsYour first website: Adding interactivityDynamic scripting with JavaScriptJavaScript frameworks and librariesJavaScript GuideIntroductionGrammar and typesControl flow and error handlingLoops and iterationFunctionsExpressions and operatorsNumbers and stringsRepresenting dates & timesRegular expressionsIndexed collectionsKeyed collectionsWorking with objectsUsing classesUsing promisesJavaScript typed arraysIterators and generatorsResource managementInternationalizationJavaScript modulesIntermediateAdvanced JavaScript objectsAsynchronous JavaScriptClient-side web APIsLanguage overviewJavaScript data structuresEquality comparisons and samenessEnumerability and ownership of propertiesClosuresAdvancedInheritance and the prototype chainMeta programmingMemory ManagementReferencesBuilt-in objectsAggregateErrorArrayArrayBufferAsyncDisposableStackAsyncFunctionAsyncGeneratorAsyncGeneratorFunctionAsyncIteratorAtomicsBigIntBigInt64ArrayBigUint64ArrayBooleanDataViewDatedecodeURI()decodeURIComponent()DisposableStackencodeURI()encodeURIComponent()Errorescape()
Deprecated
eval()EvalErrorFinalizationRegistryFloat16ArrayFloat32ArrayFloat64ArrayFunctionGeneratorGeneratorFunctionglobalThisInfinityInt8ArrayInt16ArrayInt32ArrayInternalError
Non-standard
IntlisFinite()isNaN()IteratorJSONMapMathNaNNumberObjectparseFloat()parseInt()PromiseProxyRangeErrorReferenceErrorReflectRegExpSetSharedArrayBufferStringSuppressedErrorSymbolSyntaxErrorTemporal
Experimental
TypedArrayTypeErrorUint8ArrayUint8ClampedArrayUint16ArrayUint32Arrayundefinedunescape()
Deprecated
URIErrorWeakMapWeakRefWeakSetExpressions & operatorsAddition (+)Addition assignment (+=)Assignment (=)async function expressionasync function* expressionawaitBitwise AND (&)Bitwise AND assignment (&=)Bitwise NOT (~)Bitwise OR (|)Bitwise OR assignment (|=)Bitwise XOR (^)Bitwise XOR assignment (^=)class expressionComma operator (,)Conditional (ternary) operatorDecrement (--)deleteDestructuringDivision (/)Division assignment (/=)Equality (==)Exponentiation (**)Exponentiation assignment (**=)function expressionfunction* expressionGreater than (>)Greater than or equal (>=)Grouping operator ( )import.metaimport.meta.resolve()import()inIncrement (++)Inequality (!=)instanceofLeft shift (<<)Left shift assignment (<<=)Less than (<)Less than or equal (<=)Logical AND (&&)Logical AND assignment (&&=)Logical NOT (!)Logical OR (||)Logical OR assignment (||=)Multiplication (*)Multiplication assignment (*=)newnew.targetnullNullish coalescing assignment (??=)Nullish coalescing operator (??)Object initializerOperator precedenceOptional chaining (?.)Property accessorsRemainder (%)Remainder assignment (%=)Right shift (>>)Right shift assignment (>>=)Spread syntax (...)Strict equality (===)Strict inequality (!==)Subtraction (-)Subtraction assignment (-=)superthistypeofUnary negation (-)Unary plus (+)Unsigned right shift (>>>)Unsigned right shift assignment (>>>=)void operatoryieldyield*Statements & declarationsasync functionasync function*await usingBlock statementbreakclassconstcontinuedebuggerdo...whileEmpty statementexportExpression statementforfor await...offor...infor...offunctionfunction*if...elseimportImport attributesLabeled statementletreturnswitchthrowtry...catchusingvarwhilewith
Deprecated
FunctionsArrow function expressionsDefault parametersgetMethod definitionsRest parameterssetThe arguments object[Symbol.iterator]()callee
Deprecated
lengthClassesconstructorextendsPrivate elementsPublic class fieldsstaticStatic initialization blocksRegular expressionsBackreference: \1, \2Capturing group: (...)Character class escape: \d, \D, \w, \W, \s, \SCharacter class: [...], [^...]Character escape: \n, \u{...}Disjunction: |Input boundary assertion: ^, $Literal character: a, bLookahead assertion: (?=...), (?!...)Lookbehind assertion: (?<=...), (?<!...)Modifier: (?ims-ims:...)Named backreference: \k<name>Named capturing group: (?<name>...)Non-capturing group: (?:...)Quantifier: *, +, ?, {n}, {n,}, {n,m}Unicode character class escape: \p{...}, \P{...}Wildcard: .Word boundary assertion: \b, \BErrorsAggregateError: No Promise in Promise.any was resolvedError: Permission denied to access property "x"InternalError: too much recursionRangeError: argument is not a valid code pointRangeError: BigInt division by zeroRangeError: BigInt negative exponentRangeError: form must be one of 'NFC', 'NFD', 'NFKC', or 'NFKD'RangeError: invalid array lengthRangeError: invalid dateRangeError: precision is out of rangeRangeError: radix must be an integerRangeError: repeat count must be less than infinityRangeError: repeat count must be non-negativeRangeError: x can't be converted to BigInt because it isn't an integerReferenceError: "x" is not definedReferenceError: assignment to undeclared variable "x"ReferenceError: can't access lexical declaration 'X' before initializationReferenceError: must call super constructor before using 'this' in derived class constructorReferenceError: super() called twice in derived class constructorSyntaxError: 'arguments'/'eval' can't be defined or assigned to in strict mode codeSyntaxError: "0"-prefixed octal literals are deprecatedSyntaxError: "use strict" not allowed in function with non-simple parametersSyntaxError: "x" is a reserved identifierSyntaxError: \ at end of patternSyntaxError: a declaration in the head of a for-of loop can't have an initializerSyntaxError: applying the 'delete' operator to an unqualified name is deprecatedSyntaxError: arguments is not valid in fieldsSyntaxError: await is only valid in async functions, async generators and modulesSyntaxError: await/yield expression can't be used in parameterSyntaxError: cannot use `??` unparenthesized within `||` and `&&` expressionsSyntaxError: character class escape cannot be used in class range in regular expressionSyntaxError: continue must be inside loopSyntaxError: duplicate capture group name in regular expressionSyntaxError: duplicate formal argument xSyntaxError: for-in loop head declarations may not have initializersSyntaxError: function statement requires a nameSyntaxError: functions cannot be labelledSyntaxError: getter and setter for private name #x should either be both static or non-staticSyntaxError: getter functions must have no argumentsSyntaxError: identifier starts immediately after numeric literalSyntaxError: illegal characterSyntaxError: import declarations may only appear at top level of a moduleSyntaxError: incomplete quantifier in regular expressionSyntaxError: invalid assignment left-hand sideSyntaxError: invalid BigInt syntaxSyntaxError: invalid capture group name in regular expressionSyntaxError: invalid character in class in regular expressionSyntaxError: invalid class set operation in regular expressionSyntaxError: invalid decimal escape in regular expressionSyntaxError: invalid identity escape in regular expressionSyntaxError: invalid named capture reference in regular expressionSyntaxError: invalid property name in regular expressionSyntaxError: invalid range in character classSyntaxError: invalid regexp groupSyntaxError: invalid regular expression flag "x"SyntaxError: invalid unicode escape in regular expressionSyntaxError: JSON.parse: bad parsingSyntaxError: label not foundSyntaxError: missing : after property idSyntaxError: missing ) after argument listSyntaxError: missing ) after conditionSyntaxError: missing ] after element listSyntaxError: missing } after function bodySyntaxError: missing } after property listSyntaxError: missing = in const declarationSyntaxError: missing formal parameterSyntaxError: missing name after . operatorSyntaxError: missing variable nameSyntaxError: negated character class with strings in regular expressionSyntaxError: new keyword cannot be used with an optional chainSyntaxError: nothing to repeatSyntaxError: numbers out of order in {} quantifier.SyntaxError: octal escape sequences can't be used in untagged template literals or in strict mode codeSyntaxError: parameter after rest parameterSyntaxError: private fields can't be deletedSyntaxError: property name __proto__ appears more than once in object literalSyntaxError: raw bracket is not allowed in regular expression with unicode flagSyntaxError: redeclaration of formal parameter "x"SyntaxError: reference to undeclared private field or method #xSyntaxError: rest parameter may not have a defaultSyntaxError: return not in functionSyntaxError: setter functions must have one argumentSyntaxError: string literal contains an unescaped line breakSyntaxError: super() is only valid in derived class constructorsSyntaxError: tagged template cannot be used with optional chainSyntaxError: Unexpected '#' used outside of class bodySyntaxError: Unexpected tokenSyntaxError: unlabeled break must be inside loop or switchSyntaxError: unparenthesized unary expression can't appear on the left-hand side of '**'SyntaxError: use of super property/member accesses only valid within methods or eval code within methodsSyntaxError: Using //@ to indicate sourceURL pragmas is deprecated. Use //# insteadTypeError: 'caller', 'callee', and 'arguments' properties may not be accessedTypeError: 'x' is not iterableTypeError: "x" is (not) "y"TypeError: "x" is not a constructorTypeError: "x" is not a functionTypeError: "x" is not a non-null objectTypeError: "x" is read-onlyTypeError: already executing generatorTypeError: BigInt value can't be serialized in JSONTypeError: calling a builtin X constructor without new is forbiddenTypeError: can't access/set private field or method: object is not the right classTypeError: can't assign to property "x" on "y": not an objectTypeError: can't convert BigInt to numberTypeError: can't convert x to BigIntTypeError: can't define property "x": "obj" is not extensibleTypeError: can't delete non-configurable array elementTypeError: can't redefine non-configurable property "x"TypeError: can't set prototype of this objectTypeError: can't set prototype: it would cause a prototype chain cycleTypeError: cannot use 'in' operator to search for 'x' in 'y'TypeError: class constructors must be invoked with 'new'TypeError: cyclic object valueTypeError: derived class constructor returned invalid value xTypeError: getting private setter-only propertyTypeError: Initializing an object twice is an error with private fields/methodsTypeError: invalid 'instanceof' operand 'x'TypeError: invalid Array.prototype.sort argumentTypeError: invalid assignment to const "x"TypeError: Iterator/AsyncIterator constructor can't be used directlyTypeError: matchAll/replaceAll must be called with a global RegExpTypeError: More arguments neededTypeError: null/undefined has no propertiesTypeError: property "x" is non-configurable and can't be deletedTypeError: Reduce of empty array with no initial valueTypeError: setting getter-only property "x"TypeError: WeakSet key/WeakMap value 'x' must be an object or an unregistered symbolTypeError: X.prototype.y called on incompatible typeURIError: malformed URI sequenceWarning: -file- is being assigned a //# sourceMappingURL, but already has oneWarning: unreachable code after return statementMiscJavaScript technologies overviewExecution modelLexical grammarIteration protocolsStrict modeTemplate literalsTrailing commasDeprecated features
Your blueprint for a better internet.
MDN
About
Blog
Mozilla careers
Advertise with us
MDN Plus
Product help
Contribute
MDN Community
Community resources
Writing guidelines
MDN Discord
MDN on GitHub
Developers
Web technologies
Learn web development
Guides
Tutorials
Glossary
Hacks blog
Website Privacy Notice
Cookies
Legal
Community Participation Guidelines
Visit Mozilla Corporationâs not-for-profit parent, the Mozilla Foundation.
Portions of this content are Â©1998ââ¨2025â© by individual mozilla.org contributors. Content available under a Creative Commons license.
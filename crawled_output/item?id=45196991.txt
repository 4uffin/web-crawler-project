Adding OR logic forced us to confront why users preferred raw SQL | Hacker NewsHacker Newsnew | past | comments | ask | show | jobs | submitloginAdding OR logic forced us to confront why users preferred raw SQL (signoz.io)81 points by ak_builds 22 hours ago
| hide | past | favorite | 77 comments
jerf 19 hours ago
| next [–]
At the risk of getting run off this site... Jira's search query widget, which allows in some sense nearly arbitrary SQL while providing syntax completion, making sure you don't run off the rails with actual arbitrary SQL, and supporting very deeply nested conditionals correctly is probably one of the most impressive things to me about that system. I just wish it was not such a staggeringly large pile of work to get to such a thing in other systems. Even if someone cites some sort of open source library that supports this, simply defining to that library what columns and operations you support would be a lengthy task of specification, refinement, and testing.It'd be neat if you could let more users just have SQL but there's so many ways for that to go terribly wrong nowadays, with all those nice juicy SQL features that so many engines now support.replyperching_aix 18 hours ago
| parent | next [–]
I didn't know JIRA can assist you with writing JQL, looks like I'm lost in the UI hell. I always just click Advanced and then click what I want together. Although I only need this kind of functionality very rarely, to make up for other UI grievances, so w/e.replycrabmusket 18 hours ago
| parent | prev | next [–]
Something I have been considering is a ETL pipeline that, for each customer in our system, writes only their data to a SQLite file. Then, just expose a full SQLite query facility on that file.This only works when your customers are of a reasonable size (e.g. small businesses or individuals) but could provide arbitrary analytics power.It's also a safe target for AIs to write sql against, if you're into that sort of thing.replyklysm 11 hours ago
| root | parent | next [–]
We do this with DuckDB, and leave the connection in read only mode, exposing the database over HTTP. SQL injection by design?replycrabmusket 9 hours ago
| root | parent | next [–]
Cool to hear I'm not off the deep end. Have you written anything up on this, or were you inspired by anything else? How has it worked out for you?replyklysm 4 hours ago
| root | parent | next [–]
haven’t written anything up on it, but I wouldn’t use my anecdote as an indication we aren’t off the deep end together!At a high level, we use DuckDB as an in-memory OLAP cache that’s invalidated via Postgres logical replication.We compute a lot of derived data to offer a read-heavy workload as a product.Possibly the most dubious choice I tried out recently was letting the front end just execute SQL directly against DuckDB with a thin serialization layer in the backend.The best apart about it is the hot reload feedback loop. The backend doesn’t have to rebuild to iterate quickly.replym3047 3 hours ago
| root | parent | prev | next [–]
I use a desktop system which has python as its scripting layer, and exposes data to python nodes using pandas.(In case you're wondering, https://www.knime.com/)replysixdimensional 17 hours ago
| root | parent | prev | next [–]
If you're writing out data for analytical read only use - go with DuckDb all the way, over SQLite.replycrabmusket 9 hours ago
| root | parent | next [–]
Thanks, I will look into it!replynijave 9 hours ago
| root | parent | prev | next [–]
Zuora (billing and payment SaaS) has a user facing SQL interface backed by Trino that works pretty wellreplymschuster91 9 hours ago
| root | parent | prev | next [–]
alternatively, why not use database views? That way you can make sure that customers can only see their own data. Permissions can be handled with normal database users by only granting them SELECT rights on the views.If you're afraid of users tanking performance, read replicas. As instantaneous as it gets, and no customer can tank others.replysublinear 13 hours ago
| parent | prev | next [–]
I've been using and frustrated by Jira for a long time, so I'd love to be pointed in the right direction if I'm wrong here, but JQL only lets you write severely limited "where" clauses that plug into something that probably isn't SQL at all.You cannot use JQL to pull up anything but a list of issues. You cannot aggregate fields within those issues. Many fields aren't even an option. The built-in functions are garbage. Some are redundant. Some are named similarly but do wildly different things. You can't even use subqueries or regex. Is there documentation disproving me somewhere that I'm not aware of?These are all huge problems with endless unresolved tickets on Atlassian's support pages that point out very good and very common use cases that people have desperately wanted for over a decade. The answer is always yet another plugin. Security and data integrity can't be the reason Jira search sucks since many of those plugins are buggy and have more access to the backend.As far as I can tell "JQL" was a name devised by their marketing department to make it seem more powerful than it really is and otherwise prop up a nasty plugin ecosystem that nobody wants. I sometimes feel like my outlook inbox rules are more sophisticated and that's pretty sad.replyjerf 6 hours ago
| root | parent | next [–]
Count how many places have a search on a website that let you run "((A and B) or (C and D) XOR E) AND NOT F". It's not many.The very complaints you are making are kind of my point; that you can even consider making them means they've put a lot of work into a search interface that few other search interfaces have. The vast majority of "search fields" I run into can't even do a single AND or OR; one does not get so far as to wish for those things because clearly we're miles away from them.replysublinear 5 hours ago
| root | parent | next [–]
It doesn't matter how many. Jira should be on the same level as the other tools it's commonly used alongside.GitLab has GLQL[1]. ServiceNow has CMDB[2]. Both offer more flexible queries on any data the users can see and can return arbitrary tables. The dashboards, reports, APIs, etc. are actually useful because of that. On Jira, all you get are lists of issues and dashboard widgets that are barely more helpful that the list of issues they obscure.This is expected to be all available out-of-the-box without plugins or other gotchas. Nobody should have to rewrite their scripts to run the same basic recurring jobs on another project or part of the company just because they're on a different instance and don't want to buy a plugin that is seldom used. The only reason anyone tracks projects with Jira is its familiarity. Hardly anyone uses the newer features that Atlassian has shifted focus towards. All anyone wants is the core UI, for that UI to not be so bloated and slow (and it's only getting worse), and a better JQL.[1]: https://docs.gitlab.com/user/glql/[2]: https://www.servicenow.com/products/servicenow-platform/conf...replyjraph 11 hours ago
| root | parent | prev | next [–]
> JQL only lets you write severely limited "where" clauses that plug into something that probably isn't SQL at all.That's right. JQL (Jira Query Language) is based on AQL (Atlassian Query Language), same as CQL (Confluence Query Language), and targets Lucene (IIRC), not SQL, and CQL and JQL are (I suppose!) translated to Lucene queries.These query languages are a subset of what you can do with a Solr / Lucene query string (basically the same thing as Solr is a fork of Lucene; Lucene is what is behind Atlassian products' search features IIRC). If you squint a little, you can liken it to some limited SQL where clause without the joins and the sub queries, but the target is a search platform, not an SQL database.AQL fields map to Lucene fields, and there are functions that are also (likely) translated to Lucene expressions or replaced with some stuff from the context (currentContent() for instance in CQL is replaced to the id of the current Confluence page, and parentContent() to the id of the parent of the current page - again, this is a guess).I suppose they invented this family or query languages to provide something more high level / user-friendly than raw lucene query strings, or possibly didn't want to give full access to the Lucene search capabilities for some reason.There are Maven packages provided by Atlassian to deal with AQL [1], but they are not open source (and I have not studied their code, disassembled or otherwise).I have reimplemented an AQL parser [2] from scratch using their limited docs and guesses, and, with this, implemented a CQL to Solr query translator for XWiki, mapping Confluence features to corresponding XWiki features [3]. Because people are migrating from Confluence
to XWiki and their content is sprinkled with CQL-based macros that we needed to make work.If you are curious about how a CQL statement can be translated to a Solr query (although querying fields in XWiki, not Confluence), you can look at the tests [4].I actually find AQL pretty elegant, although I'll admit I haven't used it much.[1] https://mvnrepository.com/artifact/com.atlassian.querylang[2] https://github.com/xwiki-contrib/cql/tree/master/aqlparser[3] https://github.com/xwiki-contrib/cql/tree/master/query[4] https://github.com/xwiki-contrib/cql/blob/master/query/src/t...replypas 8 hours ago
| root | parent | next [–]
thanks for the links, and ... uhh, mad respect on the xwiki CQL feature! :)a bit tangential, but isn't Solr (and ElasticSearch and probably others) all use Lucerne "indexes" (as in Lucene is a library like LevelDB)?what's strange is that most JQL that people want would translate to the most boring Hibernate query (or whatever Jira uses for relational DB access)replyjraph 8 hours ago
| root | parent | next [–]
You are totally right, I thought Solr was a Lucene fork, but it's actually built on top of Lucene, thanks for correcting me. Both are Apache projects.replygiveita 18 hours ago
| parent | prev | next [–]
JQL is a very powerful tool. No one sets up Jira perfectly. Not at first. People use anything like a label: the epic, the release version. etc. And JQL let's you get around that in the short term and find stuff.replygiveita 18 hours ago
| prev | next [–]
> v3 couldn't do this. No OR support. No complex boolean expressions. No parentheses for precedence.This wasn't a minor limitation; it was a fundamental capability gap. Users were forced to learn ClickHouse SQL, write raw queries, and maintain them as our schemas evolved. We'd built a query builder that couldn't handle real-world queries.What is it with the LinkedIn style?No XNo YNo ZIsn't A its Breplyoutlier99 17 hours ago
| parent | next [–]
It's not LinkedIn style, this is how ChatGPT generates textreplyjjani 15 hours ago
| root | parent | next [–]
It's not just ChatGPT—it's part of the inner fabric of Large Language Models.Heh. But seriously, all frontier models do it, it's in the top 3 of tells that even someone with zero LLM experience can spot.replyak_builds 15 hours ago
| parent | prev | next [–]
This article is part of our launch week and our main distribution channel is LinkedIn.Our articles are now being read by stakeholders beyond our ICP.I agree that LinkedIn/ChatGPT style isn't the best route. We cringe on it too. We are experimenting to find a middle ground between what gets more reach, while not giving into the trending writing styles.Can I please get some more feedback from you?- would you prefer more technical details in this article?
- or just a change in the sentence structure that is more natural (like this response)?
- or both?replytux3 12 hours ago
| root | parent | next [–]
The technical content is okay, but there's some fluff with a characteristic LLM signature that cheapens the whole thing. Instead of an article hand-crafted by human hands, it screams to the reader that they are currently reading slop.I would rather not read other people's slop. I could pass your article through an LLM myself, if I wanted that. Here's just one of the most tired snowclones that current LLMs love, everywhere in your content:>This wasn't a minor limitation; it was a fundamental capability gap>context-switch not just between data types, but between entirely different mental models of how to query data.>This wasn't something we asked them to do. They discovered that the query builder could now handle their complex cases, and they preferred it over raw SQL.>That's not just a technical achievement. That's validation that we finally understood the problem we were trying to solve.It wasn't just a minor stylistic issue; It was a signal to close the page.replyporker 9 hours ago
| root | parent | next [–]
Isn't that though the narrative arc being shaped? We see it everywhere now, but just because LLMs like to output it doesn't make the structure you're highlighting bad.Overall I found it a decent piece, a few too many "<term>: <explanation>" blocks for my taste but better than what I can write - and than most of the tech-industry blogging I come across.replyak_builds 12 hours ago
| root | parent | prev | next [–]
Feedback well taken! I'll update the articles soon and do better henceforth.replyhuflungdung 9 hours ago
| root | parent | prev | next [–]
…”for me”Everyone else managed to read it fine.replygiveita 12 hours ago
| root | parent | prev | next [–]
Tropes in general I think become distracting. The ChatGPT style isn't bad in itself (just as one Giblhi cartoon isn't bad but 100000 are!)But you could survey more people as maybe it is just me!replyryoshu 20 hours ago
| prev | next [–]
I still struggle with ORMs. SQL is... declarative. If you're working with multiple RDBMSs, sure? Maybe I want my local dev to be sqlite and scaled be postgres? I've never run into that in production. A DSL on top of a DSL doesn't make a lot of sense.replyt-writescode 19 hours ago
| parent | next [–]
Hand-rolling SQL inside another programming language comes with some unpleasantness, like protecting against SQL injection and making sure the SQL is valid, especially when hand-constructing the query based on input parameters: “sort ascending? Descending? Filter all but things in this group? etc.”Parameter management in some languages are unpleasant, like how JDBC only has positional arguments; and any time you do string concat in a language, you start getting in danger of misformed SQL.Ultra basic ORMs, like Exposed (Kotlin), are well-tested frameworks that do exactly what I want. Want a single value in the =? Or want it to be an “in”? Or what if it’s null? Handled. No special string management. Want parameters? Handled.When I see pure ORM’d code, I can feel safe expecting it to be protected from injection and formatting issues. It’s reduced cognitive load and greater safety.When I see raw string SQL management, I have to put another layer of care and attention to try and make sure (and maybe still fail) there’s no application-crashing mistakes in that part of code.It’s kinda like working with typed and compiled code. Greater protection from error.replywebstrand 17 hours ago
| root | parent | next [–]
It sounds like you're describing a query builders which, unlike true ORMs, don't attempt to mask the object-relational boundary. They only help you build queries in a convenient way and sometimes type-safe way. Query builders are great.ORMs are not query builders. The problem with ORMs is that they hide the query logic from you. It's not clear what's getting joined in, how its getting joined in, or if its actually 1 or N queries. The further you get from a straight query builder, too, the fewer SQL features you have access to, such as parameterized joins, CTEs, window functions, etc. Sometimes you can hack those into the ORM, but often you have to resort to string concat and build the parameterized query and arguments manually.I've never used Exposed, but from what I can tell it's kind of a hybrid? the query builder parts look great, but I'd still be wary of the ORM parts.I've never had a good experience debugging performance issues in ORM-generated queries. Maybe I haven't used the right ones, but the libraries I've used have gone out of their way to hide how the query is actually being executed and only have obtuse levers to tweak that execution. Sure you can see the raw logs of what queries the ORM executed, but you can't easily figure out why its chosen a particular strategy. Or you can't easily make it stop using a pathological join ordering.replyprmph 10 hours ago
| root | parent | next [–]
If one can update the underlying Db, I've developed an ORM pattern that I use in my projects that works very well.They keys is to encapsulate most of the (possibly complex) CRUD logic in Db functions (for retrieval these would be table-valued functions) and access these from the application side as virtual tables.I also have capable but easy to use filtering/sorting/paging operators and combinators in the ORM that are translated into SQL where/sort/limit clauses.Because the heavy lifting is already done by the db functions (which you have full control of to use whatever SQL you need), the pattern is actually quite powerful but easy to use.You can define virtual read only tables, several virtual tables that access the same actual table in different way, custom operators that transcend SQL, etcreplyandoando 16 hours ago
| root | parent | prev | next [–]
I HATE ORMs. I end up spending an hour or two trying to figure out why something isnt working for what should be a simple query.Theyre also seem quite restrictive to what raw sql can do.replymonkeyelite 18 hours ago
| root | parent | prev | next [–]
You’re arguing against a straw man. All major language sql libraries are not based on string manipulation and provide things like escaping, arguments, etc out of the box.replykaoD 12 hours ago
| root | parent | next [–]
Query builders are still an antipattern (what we traditionally think of when we say query builders) because they are still a DSL that (1) you have to learn along with SQL and (2) never map cleanly to actual SQL, so you always have to resort to `.raw` calls when you need anything more complex than a simple SELECT+JOIN.Even for simple SELECTs, I lost count of how many times I had to enable runtime DEBUG logging in my query builders to get a query that I can copy-paste into my DB client for debugging, data exploring, etc. I should be able to copy-paste my query from code and run it in `psql` with minimal changes.Raw SQL is the way to go[0]. Period. You just need a thin wrapper on top of it that adds escaping, arguments, type-safety and other QoL.[0] https://gajus.medium.com/stop-using-knex-js-and-earn-30-bf41...replyesafak 5 hours ago
| root | parent | next [–]
That thin wrapper is a query builder.replykaoD 5 hours ago
| root | parent | next [–]
> antipattern (what we traditionally think of when we say query builders)replyameliaquining 18 hours ago
| root | parent | prev | next [–]
Only for parameterization over scalar values. If you want to do any kind of composition more sophisticated than that, you're either stitching together strings or using some kind of more heavyweight abstraction like an ORM.replymonkeyelite 18 hours ago
| root | parent | next [–]
That’s because the composition is supposed to be inside sql. Views, functions, etc.This is another reason why the ORM is a leaky abstraction - it hides all the best features from you.replyameliaquining 18 hours ago
| root | parent | next [–]
I suspect the biggest reason those aren't more popular is that they usually have to be stored as state in the database, which isn't what you want when developing an application. You want all of your query logic to be versioned with your application code.replybranko_d 16 hours ago
| root | parent | next [–]
> You want all of your query logic to be versioned with your application code.SQL can be stored in version control just as well as any other code. This can include application-level queries as well as the DDL SQL which defines the actual structure of your database.It's sad that tooling for this kind of workflow doesn't seem to be particularly good across the board, Visual Studio being somewhat of an exception.replyameliaquining 16 hours ago
| root | parent | next [–]
The problem isn't version-controlling the SQL; it's making sure that, when a particular build of your app executes a query that calls out to a user-defined function, it uses the SQL function code from the same commit that the app itself was built from. Otherwise you have a potential source of version skew, and those are always really annoying and unpleasant to deal with.I think Postgres sort of supports this but it's really clunky, and also I think you'd have to run the function-creation code on every connection; I don't know whether that would create any performance problems.What does Visual Studio do?replysnuxoll 15 hours ago
| root | parent | next [–]
You just mentioned PostgreSQL, which, like pretty much every RDMBS sans MySQL, DB2/400, and maybe DB2/ZOS (never worked with the ZOS variant) supports schemas. If you need to worry about this, keep your tables that actually contain your data in one schema, then keep views, functions/stored procedures, etc. in separate schemas every time you make incompatible changes.The database is a separate component, the biggest mistake nearly every developer makes is trying to make a single application own it. Let me tell you, from experience, the chances that this one single application will be the only thing that every connects to your database past initial development is slim. "Oh, but we're doing microservices and everything only ever talks over HTTP or gRPC" - yeah, sure, and I don't have a backlog of tech debt a mile long.replybranko_d 7 hours ago
| root | parent | prev | next [–]
> when a particular build of your app executes a query that calls out to a user-defined function, it uses the SQL function code from the same commit that the app itself was built fromI don't really see a "problem" here. Having everything in the same repo is probably the easiest way to ensure that the client cannot go out of sync with the database. When making a release, create a Git tag and deploy both client and database from there.But you must make sure you know which tag is deployed at each customer. We use naming conventions for that (the name of the customer is part of the Git tag name), or you could hold that mapping externally if necessary.Once you have that, making a client-level hotfix for a specific customer is (relatively) easy - just branch from the customer's release tag, do the changes you need, run the tests, and there is high probability everything will work properly. Once you release the hotfix, you create another tag and remember that this tag is now installed at the customer, and so on...If you make changes to the database, then of course you still need to have an upgrade procedure from one version of the database to another, but you can be confident that the client will never query the "wrong" database version. And since both old and new database structure are just SQL files under different Git tags, you can discover exactly what changed by just by diffing.> What does Visual Studio do?Visual Studio has a special SQL project type, where you can keep you base table definitions, as well as all the SQL code (stored procedures, functions, views, user-defined types, indexes etc.). You can group the SQL project together with client projects, tools, automated tests and benchmarks in the same "solution" (kind of a project-of-projects). When working on the product, you load that solution, and you have all dependencies in one place, right in the Solution Explorer. This eases navigation and minimizes dependencies whose source code you cannot (easily) see.After you make your changes, you deploy to the local database (we use the free SQL Server Developer Edition, other databases have their own free editions), run/debug tests, run/debug clients as needed. You can even start debugging a C# test or client application and step into T-SQL stored procedure seamlessly, which can be a very powerful tool for ferreting-out difficult bugs. When you are done with your changes, commit to Git, let the CI double-check the tests and make the build for the the last-row-of-defense manual QA testing. Then deploy, associate the new Git tag to the customer, rinse-and-repeat...Basically, we treat SQL like every other code, and manage SQL dependencies not fundamentally unlike any other dependencies.replymonkeyelite 18 hours ago
| root | parent | prev | next [–]
In most organizations a database is broader than any individual application - both in lifecycle and scope. So it makes sense that this state exists in a different way.I suspect it’s because people never learned to use them, but they did learn to use the ORM.replyameliaquining 16 hours ago
| root | parent | next [–]
The textbooks all say that, but is it really true in practice? I suspect it's a bit of holdover conventional wisdom from an earlier era of software. Usually, when I've created a database for a particular app, it was never used by anything else besides that app (and manual queries, for which versioning is mostly not relevant).You might choose to have a set of views and functions that are versioned separately from your app, for the same reasons you might choose to set up a microservice. But as with microservices, it should be a deliberate decision that you make because you're getting something out of it that outweighs the complexity costs and version-skew headaches; it should not be the default way to do composition.replybaq 9 hours ago
| root | parent | next [–]
It’s absolutely true. Nobody should be building a microservice architecture for a product without a proven market fit, monolithic development is just faster at this stage, and when you get around to scaling it once you outgrow it (which should be much later than conventional microservice wisdom agrees) the database isn’t the bottleneck anyway and hence stays monolithic (don’t confuse with adding shards).replybranko_d 17 hours ago
| root | parent | prev | next [–]
> Only for parameterization over scalar values.ADO.NET has full support for table-valued parameters.replyameliaquining 16 hours ago
| root | parent | next [–]
That's part of .NET Framework and therefore legacy, right? Do the database libraries from recent versions of .NET do this?In any case, it's just one framework; previous comment said "all major languages". And it's useful to be able to abstract and compose over expressions and predicates and such, not just data values, which this still doesn't help with.replybranko_d 7 hours ago
| root | parent | next [–]
> That's part of .NET Framework and therefore legacy, right? Do the database libraries from recent versions of .NET do this?ADO.NET is available both in the legacy Windows-only .NET Framework and in the new cross-platform .NET (previously known as .NET Core).> In any case, it's just one framework; previous comment said "all major languages".Well, you are not implementing a piece of code in "all major languages" - you can pick the one that fits the problem best.> And it's useful to be able to abstract and compose over expressions and predicates and such, not just data values, which this still doesn't help with.You can do that via LINQ - there is even special query-like syntax built right into C# for that that looks like this:
var companyNameQuery =
from cust in nw.Customers
where cust.City == "London"
select cust.CompanyName;
This does NOT load the entire table in memory just to filter on City. It actually transpiles to SQL which does the filtering on the server.But anything non-trivial is much better done in SQL proper, IMO. Most of the time, at least for OLTP, you'll be using static SQL - that is you will not need to change the text of the SQL query, just parameters. But dynamic SQL is a thing and can be very useful on occasion - which is string concatenation with all the problems that might bring.replynever_inline 19 hours ago
| parent | prev | next [–]
How do you do conditional filters in pure SQL from a backend Java / Python app, without doing string concatenation?Not a fan of all the proxy object circus ORMs do but I'd leave row-> domain object mapping and filter building to some library. Sweet spot is probably something akin to Android Room / Micronaut Data JDBC.replyminitech 19 hours ago
| root | parent | next [–]
Query builders that operate at the SQL level. (A popular example of that in Python is SQLAlchemy Core, but there are better ways to do it, especially in better-typed languages.)replyfoobazgt 18 hours ago
| root | parent | prev | next [–]
JOOQ (http://jooq.org) is pretty fantastic for this, and it's my go-to for working with RDBMs' on the JVM. It provides a DSL-like API that lets you write pretty much any SQL you need in a type-safe way (without string concatenation).replysgarland 9 hours ago
| root | parent | prev | next [–]
SQL has CASE statements, if you’d really like to have all branching logic in pure SQL.replycrazygringo 19 hours ago
| root | parent | prev | next [–]
What's wrong with string concatenation?replywhatevaa 11 hours ago
| root | parent | next [–]
Guaranteed source of bugs in complex cases.replycrazygringo 8 hours ago
| root | parent | next [–]
More complex cases are more likely to have bugs period, just in their logic.String concatenation isn't really a major source of that. Just make sure your parentheses match, as you need to do no matter what, and include a space at the start and end of each string to make sure you don't accidentally smush terms together likethis.replyt-writescode 19 hours ago
| root | parent | prev | next [–]
Simpler SQL injection risk and more testing to make sure all potential branching paths don’t result in invalid SQL.replywebstrand 18 hours ago
| root | parent | next [–]
There's zero danger of sql injection so long as everything is being passed by parameters. You just concatenate placeholders when you need string concatenation to build the query.replycrazygringo 17 hours ago
| root | parent | next [–]
Exactly this.And if you're testing, you've got to test every query combination anyways. It's not just syntax that can be wrong, but logic and performance.replypaulddraper 19 hours ago
| root | parent | prev | next [–]
String concatenationreplyXss3 19 hours ago
| root | parent | next [–]
No, we must build 16 more layers of pointless abstraction in a new DSL.replyozgrakkurt 6 hours ago
| parent | prev | next [–]
Can’t relate this comment to the article. They can’t just run user sql on DB because they are changing internal db schema between releases. And they can’t implement real sql because it is massive compared to some simple query dslreplychillfox 19 hours ago
| parent | prev | next [–]
My main issue with ORMs is they always end up being just another thing to learn, adding needless complexity. They are not an alternative to SQL as you always end up having to understand what kind of SQL they create and how it works for either performance or complex queries.replydec0dedab0de 19 hours ago
| parent | prev | next [–]
I just want to write one language at a time if I can.
I like sql when querying directly, almost as a UI of sorts, but it’s not my favorite when I am just trying to get my code to work, and the database is a relatively minor detail.replylmm 9 hours ago
| parent | prev | next [–]
SQL is just extremely bad on top of being poorly integrated with the host language. Middle-endian order, terrible abstraction capabilities, no test support to speak of, essentially no project management tooling...I use ORMs so that I can write the thing I want to do in a vaguely reasonable language, just like I manipulate XML datastructures in code instead of writing XSLT.replyest 17 hours ago
| prev | next [–]
> Stop making decisions for users.yes! please stop making webpages background dark. It's a terrible design for ppl with astigmatism like me...replyak_builds 15 hours ago
| parent | next [–]
Thank you for educating me on astigmatism. I wasn't aware of the condition.We are revamping the design. I'll ensure I understand more about this and make it more accessible.Devs seem to prefer dark theme across the brand (eg Supabase, Linear). Hence, the current choice.replyflowerthoughts 15 hours ago
| prev | next [–]
One of my guiding principles is "avoid indirection unless you add abstraction." If what you're doing is a query language, then keeping that transparent and using existing languages is a good idea, unless you can motivate a new language with a new mental model. E.g. it might be better to write an SQL query validator than a DSL.replyprpl 17 hours ago
| prev | next [–]
Salesforce’s SOQL, like was mentioned with Jira’s JQL, also
handles this type of thing _okay_ without explicit joins.I think “SQL is the interface” even for telemtry is the thing that truly makes sense, but it is messy with logs compared to splunk for examplereplyshakna 16 hours ago
| parent | next [–]
SoQL's lack of joins and subqueries makes it a real pain in my life. `having` and `group by` are not enough when doing a lot of things - like confirming data migration of 40m objects.Can't do a query builder in one step, or must write Apex.replyankitnayan 13 hours ago
| root | parent | next [–]
and here query builder helps by making it earier to do cross-signal joins and subqueries. I see that is upcoming in SigNoz https://signoz.io/blog/query-builder-v5/#what-we-couldnt-shi...replygm678 16 hours ago
| prev | next [–]
I hate getting that 'is this LLM output?' feeling halfway through so many articles these days. The article is good but sentences like "This wasn't a minor limitation; it was a fundamental capability gap." are painful to read.> Currently, logs and traces live in separate worlds. You can see that a trace has an error, and you can see related logs, but you can't query them together.I've looked into SigNoz a few times but still using Grafana. The former does look promising, and features like this would start to make the case for maybe switching.replyankitnayan 13 hours ago
| parent | next [–]
You might also like the interactive dashboard feauture that was released in the recent launch week https://www.youtube.com/watch?v=YQTQXq0F5Iw&ab_channel=SigNo...replymonkeyelite 18 hours ago
| prev | next [–]
Is it actually hard to build a DSL for the kind of query’s they are talking about? Seems like it would be a 50 line SICP exercise.replyameliaquining 18 hours ago
| parent | next [–]
Conveniently, it's open core, so you can look: https://github.com/SigNoz/signoz/tree/main/pkg/querybuilderSeems to be 3978 lines of Go at present.replyecshafer 17 hours ago
| root | parent | next [–]
Go is pretty wordy, so 50 lines of scheme would be a bit of an exaggeration, but a good enough schemer could probably get it down therereplyfoxglacier 12 hours ago
| prev [–]
> hide complexity to "simplify" the experienceThis is a chronic problem in software. What I do instead is either omit the complexity or make it as visible as everything else. If it's not worth making it discoverable, it's not worth having. If you omit it, you get customer feedback about its importance instead of them struggling in silence.reply
Guidelines | FAQ | Lists | API | Security | Legal | Apply to YC | Contact
Search:
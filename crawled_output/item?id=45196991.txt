Adding OR logic forced us to confront why users preferred raw SQL | Hacker NewsHacker Newsnew | past | comments | ask | show | jobs | submitloginAdding OR logic forced us to confront why users preferred raw SQL (signoz.io)46 points by ak_builds 8 hours ago
| hide | past | favorite | 44 comments
jerf 5 hours ago
| next [–]
At the risk of getting run off this site... Jira's search query widget, which allows in some sense nearly arbitrary SQL while providing syntax completion, making sure you don't run off the rails with actual arbitrary SQL, and supporting very deeply nested conditionals correctly is probably one of the most impressive things to me about that system. I just wish it was not such a staggeringly large pile of work to get to such a thing in other systems. Even if someone cites some sort of open source library that supports this, simply defining to that library what columns and operations you support would be a lengthy task of specification, refinement, and testing.It'd be neat if you could let more users just have SQL but there's so many ways for that to go terribly wrong nowadays, with all those nice juicy SQL features that so many engines now support.replycrabmusket 4 hours ago
| parent | next [–]
Something I have been considering is a ETL pipeline that, for each customer in our system, writes only their data to a SQLite file. Then, just expose a full SQLite query facility on that file.This only works when your customers are of a reasonable size (e.g. small businesses or individuals) but could provide arbitrary analytics power.It's also a safe target for AIs to write sql against, if you're into that sort of thing.replysixdimensional 3 hours ago
| root | parent | next [–]
If you're writing out data for analytical read only use - go with DuckDb all the way, over SQLite.replyperching_aix 4 hours ago
| parent | prev | next [–]
I didn't know JIRA can assist you with writing JQL, looks like I'm lost in the UI hell. I always just click Advanced and then click what I want together. Although I only need this kind of functionality very rarely, to make up for other UI grievances, so w/e.replygiveita 4 hours ago
| parent | prev | next [–]
JQL is a very powerful tool. No one sets up Jira perfectly. Not at first. People use anything like a label: the epic, the release version. etc. And JQL let's you get around that in the short term and find stuff.replygiveita 4 hours ago
| prev | next [–]
> v3 couldn't do this. No OR support. No complex boolean expressions. No parentheses for precedence.This wasn't a minor limitation; it was a fundamental capability gap. Users were forced to learn ClickHouse SQL, write raw queries, and maintain them as our schemas evolved. We'd built a query builder that couldn't handle real-world queries.What is it with the LinkedIn style?No XNo YNo ZIsn't A its Breplyak_builds 1 hour ago
| parent | next [–]
This article is part of our launch week and our main distribution channel is LinkedIn.Our articles are now being read by stakeholders beyond our ICP.I agree that LinkedIn/ChatGPT style isn't the best route. We cringe on it too. We are experimenting to find a middle ground between what gets more reach, while not giving into the trending writing styles.Can I please get some more feedback from you?- would you prefer more technical details in this article?
- or just a change in the sentence structure that is more natural (like this response)?
- or both?replyoutlier99 3 hours ago
| parent | prev | next [–]
It's not LinkedIn style, this is how ChatGPT generates textreplyjjani 2 hours ago
| root | parent | next [–]
It's not just ChatGPT—it's part of the inner fabric of Large Language Models.Heh. But seriously, all frontier models do it, it's in the top 3 of tells that even someone with zero LLM experience can spot.replyryoshu 6 hours ago
| prev | next [–]
I still struggle with ORMs. SQL is... declarative. If you're working with multiple RDBMSs, sure? Maybe I want my local dev to be sqlite and scaled be postgres? I've never run into that in production. A DSL on top of a DSL doesn't make a lot of sense.replyt-writescode 5 hours ago
| parent | next [–]
Hand-rolling SQL inside another programming language comes with some unpleasantness, like protecting against SQL injection and making sure the SQL is valid, especially when hand-constructing the query based on input parameters: “sort ascending? Descending? Filter all but things in this group? etc.”Parameter management in some languages are unpleasant, like how JDBC only has positional arguments; and any time you do string concat in a language, you start getting in danger of misformed SQL.Ultra basic ORMs, like Exposed (Kotlin), are well-tested frameworks that do exactly what I want. Want a single value in the =? Or want it to be an “in”? Or what if it’s null? Handled. No special string management. Want parameters? Handled.When I see pure ORM’d code, I can feel safe expecting it to be protected from injection and formatting issues. It’s reduced cognitive load and greater safety.When I see raw string SQL management, I have to put another layer of care and attention to try and make sure (and maybe still fail) there’s no application-crashing mistakes in that part of code.It’s kinda like working with typed and compiled code. Greater protection from error.replywebstrand 3 hours ago
| root | parent | next [–]
It sounds like you're describing a query builders which, unlike true ORMs, don't attempt to mask the object-relational boundary. They only help you build queries in a convenient way and sometimes type-safe way. Query builders are great.ORMs are not query builders. The problem with ORMs is that they hide the query logic from you. It's not clear what's getting joined in, how its getting joined in, or if its actually 1 or N queries. The further you get from a straight query builder, too, the fewer SQL features you have access to, such as parameterized joins, CTEs, window functions, etc. Sometimes you can hack those into the ORM, but often you have to resort to string concat and build the parameterized query and arguments manually.I've never used Exposed, but from what I can tell it's kind of a hybrid? the query builder parts look great, but I'd still be wary of the ORM parts.I've never had a good experience debugging performance issues in ORM-generated queries. Maybe I haven't used the right ones, but the libraries I've used have gone out of their way to hide how the query is actually being executed and only have obtuse levers to tweak that execution. Sure you can see the raw logs of what queries the ORM executed, but you can't easily figure out why its chosen a particular strategy. Or you can't easily make it stop using a pathological join ordering.replyandoando 2 hours ago
| root | parent | next [–]
I HATE ORMs. I end up spending an hour or two trying to figure out why something isnt working for what should be a simple query.Theyre also seem quite restrictive to what raw sql can do.replymonkeyelite 4 hours ago
| root | parent | prev | next [–]
You’re arguing against a straw man. All major language sql libraries are not based on string manipulation and provide things like escaping, arguments, etc out of the box.replyameliaquining 4 hours ago
| root | parent | next [–]
Only for parameterization over scalar values. If you want to do any kind of composition more sophisticated than that, you're either stitching together strings or using some kind of more heavyweight abstraction like an ORM.replymonkeyelite 4 hours ago
| root | parent | next [–]
That’s because the composition is supposed to be inside sql. Views, functions, etc.This is another reason why the ORM is a leaky abstraction - it hides all the best features from you.replyameliaquining 4 hours ago
| root | parent | next [–]
I suspect the biggest reason those aren't more popular is that they usually have to be stored as state in the database, which isn't what you want when developing an application. You want all of your query logic to be versioned with your application code.replybranko_d 2 hours ago
| root | parent | next [–]
> You want all of your query logic to be versioned with your application code.SQL can be stored in version control just as well as any other code. This can include application-level queries as well as the DDL SQL which defines the actual structure of your database.It's sad that tooling for this kind of workflow doesn't seem to be particularly good across the board, Visual Studio being somewhat of an exception.replyameliaquining 2 hours ago
| root | parent | next [–]
The problem isn't version-controlling the SQL; it's making sure that, when a particular build of your app executes a query that calls out to a user-defined function, it uses the SQL function code from the same commit that the app itself was built from. Otherwise you have a potential source of version skew, and those are always really annoying and unpleasant to deal with.I think Postgres sort of supports this but it's really clunky, and also I think you'd have to run the function-creation code on every connection; I don't know whether that would create any performance problems.What does Visual Studio do?replysnuxoll 1 hour ago
| root | parent | next [–]
You just mentioned PostgreSQL, which, like pretty much every RDMBS sans MySQL, DB2/400, and maybe DB2/ZOS (never worked with the ZOS variant) supports schemas. If you need to worry about this, keep your tables that actually contain your data in one schema, then keep views, functions/stored procedures, etc. in separate schemas every time you make incompatible changes.The database is a separate component, the biggest mistake nearly every developer makes is trying to make a single application own it. Let me tell you, from experience, the chances that this one single application will be the only thing that every connects to your database past initial development is slim. "Oh, but we're doing microservices and everything only ever talks over HTTP or gRPC" - yeah, sure, and I don't have a backlog of tech debt a mile long.replymonkeyelite 4 hours ago
| root | parent | prev | next [–]
In most organizations a database is broader than any individual application - both in lifecycle and scope. So it makes sense that this state exists in a different way.I suspect it’s because people never learned to use them, but they did learn to use the ORM.replyameliaquining 2 hours ago
| root | parent | next [–]
The textbooks all say that, but is it really true in practice? I suspect it's a bit of holdover conventional wisdom from an earlier era of software. Usually, when I've created a database for a particular app, it was never used by anything else besides that app (and manual queries, for which versioning is mostly not relevant).You might choose to have a set of views and functions that are versioned separately from your app, for the same reasons you might choose to set up a microservice. But as with microservices, it should be a deliberate decision that you make because you're getting something out of it that outweighs the complexity costs and version-skew headaches; it should not be the default way to do composition.replybranko_d 3 hours ago
| root | parent | prev | next [–]
> Only for parameterization over scalar values.ADO.NET has full support for table-valued parameters.replyameliaquining 2 hours ago
| root | parent | next [–]
That's part of .NET Framework and therefore legacy, right? Do the database libraries from recent versions of .NET do this?In any case, it's just one framework; previous comment said "all major languages". And it's useful to be able to abstract and compose over expressions and predicates and such, not just data values, which this still doesn't help with.replynever_inline 5 hours ago
| parent | prev | next [–]
How do you do conditional filters in pure SQL from a backend Java / Python app, without doing string concatenation?Not a fan of all the proxy object circus ORMs do but I'd leave row-> domain object mapping and filter building to some library. Sweet spot is probably something akin to Android Room / Micronaut Data JDBC.replyminitech 5 hours ago
| root | parent | next [–]
Query builders that operate at the SQL level. (A popular example of that in Python is SQLAlchemy Core, but there are better ways to do it, especially in better-typed languages.)replyfoobazgt 4 hours ago
| root | parent | prev | next [–]
JOOQ (http://jooq.org) is pretty fantastic for this, and it's my go-to for working with RDBMs' on the JVM. It provides a DSL-like API that lets you write pretty much any SQL you need in a type-safe way (without string concatenation).replycrazygringo 5 hours ago
| root | parent | prev | next [–]
What's wrong with string concatenation?replyt-writescode 5 hours ago
| root | parent | next [–]
Simpler SQL injection risk and more testing to make sure all potential branching paths don’t result in invalid SQL.replywebstrand 4 hours ago
| root | parent | next [–]
There's zero danger of sql injection so long as everything is being passed by parameters. You just concatenate placeholders when you need string concatenation to build the query.replycrazygringo 3 hours ago
| root | parent | next [–]
Exactly this.And if you're testing, you've got to test every query combination anyways. It's not just syntax that can be wrong, but logic and performance.replypaulddraper 5 hours ago
| root | parent | prev | next [–]
String concatenationreplyXss3 5 hours ago
| root | parent | next [–]
No, we must build 16 more layers of pointless abstraction in a new DSL.replychillfox 5 hours ago
| parent | prev | next [–]
My main issue with ORMs is they always end up being just another thing to learn, adding needless complexity. They are not an alternative to SQL as you always end up having to understand what kind of SQL they create and how it works for either performance or complex queries.replydec0dedab0de 5 hours ago
| parent | prev | next [–]
I just want to write one language at a time if I can.
I like sql when querying directly, almost as a UI of sorts, but it’s not my favorite when I am just trying to get my code to work, and the database is a relatively minor detail.replyflowerthoughts 1 hour ago
| prev | next [–]
One of my guiding principles is "avoid indirection unless you add abstraction." If what you're doing is a query language, then keeping that transparent and using existing languages is a good idea, unless you can motivate a new language with a new mental model. E.g. it might be better to write an SQL query validator than a DSL.replyest 4 hours ago
| prev | next [–]
> Stop making decisions for users.yes! please stop making webpages background dark. It's a terrible design for ppl with astigmatism like me...replyak_builds 1 hour ago
| parent | next [–]
Thank you for educating me on astigmatism. I wasn't aware of the condition.We are revamping the design. I'll ensure I understand more about this and make it more accessible.Devs seem to prefer dark theme across the brand (eg Supabase, Linear). Hence, the current choice.replyprpl 4 hours ago
| prev | next [–]
Salesforce’s SOQL, like was mentioned with Jira’s JQL, also
handles this type of thing _okay_ without explicit joins.I think “SQL is the interface” even for telemtry is the thing that truly makes sense, but it is messy with logs compared to splunk for examplereplyshakna 2 hours ago
| parent | next [–]
SoQL's lack of joins and subqueries makes it a real pain in my life. `having` and `group by` are not enough when doing a lot of things - like confirming data migration of 40m objects.Can't do a query builder in one step, or must write Apex.replymonkeyelite 4 hours ago
| prev | next [–]
Is it actually hard to build a DSL for the kind of query’s they are talking about? Seems like it would be a 50 line SICP exercise.replyameliaquining 4 hours ago
| parent | next [–]
Conveniently, it's open core, so you can look: https://github.com/SigNoz/signoz/tree/main/pkg/querybuilderSeems to be 3978 lines of Go at present.replyecshafer 4 hours ago
| root | parent | next [–]
Go is pretty wordy, so 50 lines of scheme would be a bit of an exaggeration, but a good enough schemer could probably get it down therereplygm678 2 hours ago
| prev [–]
I hate getting that 'is this LLM output?' feeling halfway through so many articles these days. The article is good but sentences like "This wasn't a minor limitation; it was a fundamental capability gap." are painful to read.> Currently, logs and traces live in separate worlds. You can see that a trace has an error, and you can see related logs, but you can't query them together.I've looked into SigNoz a few times but still using Grafana. The former does look promising, and features like this would start to make the case for maybe switching.reply
Guidelines | FAQ | Lists | API | Security | Legal | Apply to YC | Contact
Search:
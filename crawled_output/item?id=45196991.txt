Adding OR logic forced us to confront why users preferred raw SQL | Hacker NewsHacker Newsnew | past | comments | ask | show | jobs | submitloginAdding OR logic forced us to confront why users preferred raw SQL (signoz.io)53 points by ak_builds 10 hours ago
| hide | past | favorite | 53 comments
jerf 7 hours ago
| next [–]
At the risk of getting run off this site... Jira's search query widget, which allows in some sense nearly arbitrary SQL while providing syntax completion, making sure you don't run off the rails with actual arbitrary SQL, and supporting very deeply nested conditionals correctly is probably one of the most impressive things to me about that system. I just wish it was not such a staggeringly large pile of work to get to such a thing in other systems. Even if someone cites some sort of open source library that supports this, simply defining to that library what columns and operations you support would be a lengthy task of specification, refinement, and testing.It'd be neat if you could let more users just have SQL but there's so many ways for that to go terribly wrong nowadays, with all those nice juicy SQL features that so many engines now support.replycrabmusket 6 hours ago
| parent | next [–]
Something I have been considering is a ETL pipeline that, for each customer in our system, writes only their data to a SQLite file. Then, just expose a full SQLite query facility on that file.This only works when your customers are of a reasonable size (e.g. small businesses or individuals) but could provide arbitrary analytics power.It's also a safe target for AIs to write sql against, if you're into that sort of thing.replyklysm 1 minute ago
| root | parent | next [–]
We do this with DuckDB, and leave the connection in read only mode, exposing the database over HTTP. SQL injection by design?replysixdimensional 5 hours ago
| root | parent | prev | next [–]
If you're writing out data for analytical read only use - go with DuckDb all the way, over SQLite.replyperching_aix 6 hours ago
| parent | prev | next [–]
I didn't know JIRA can assist you with writing JQL, looks like I'm lost in the UI hell. I always just click Advanced and then click what I want together. Although I only need this kind of functionality very rarely, to make up for other UI grievances, so w/e.replysublinear 1 hour ago
| parent | prev | next [–]
I've been using and frustrated by Jira for a long time, so I'd love to be pointed in the right direction if I'm wrong here, but JQL only lets you write severely limited "where" clauses that plug into something that probably isn't SQL at all.You cannot use JQL to pull up anything but a list of issues. You cannot aggregate fields within those issues. Many fields aren't even an option. The built-in functions are garbage. Some are redundant. Some are named similarly but do wildly different things. You can't even use subqueries or regex. Is there documentation disproving me somewhere that I'm not aware of?These are all huge problems with endless unresolved tickets on Atlassian's support pages that point out very good and very common use cases that people have desperately wanted for over a decade. The answer is always yet another plugin. Security and data integrity can't be the reason Jira search sucks since many of those plugins are buggy and have more access to the backend.As far as I can tell "JQL" was a name devised by their marketing department to make it seem more powerful than it really is and otherwise prop up a nasty plugin ecosystem that nobody wants. I sometimes feel like my outlook inbox rules are more sophisticated and that's pretty sad.replygiveita 6 hours ago
| parent | prev | next [–]
JQL is a very powerful tool. No one sets up Jira perfectly. Not at first. People use anything like a label: the epic, the release version. etc. And JQL let's you get around that in the short term and find stuff.replygiveita 6 hours ago
| prev | next [–]
> v3 couldn't do this. No OR support. No complex boolean expressions. No parentheses for precedence.This wasn't a minor limitation; it was a fundamental capability gap. Users were forced to learn ClickHouse SQL, write raw queries, and maintain them as our schemas evolved. We'd built a query builder that couldn't handle real-world queries.What is it with the LinkedIn style?No XNo YNo ZIsn't A its Breplyoutlier99 5 hours ago
| parent | next [–]
It's not LinkedIn style, this is how ChatGPT generates textreplyjjani 4 hours ago
| root | parent | next [–]
It's not just ChatGPT—it's part of the inner fabric of Large Language Models.Heh. But seriously, all frontier models do it, it's in the top 3 of tells that even someone with zero LLM experience can spot.replyak_builds 3 hours ago
| parent | prev | next [–]
This article is part of our launch week and our main distribution channel is LinkedIn.Our articles are now being read by stakeholders beyond our ICP.I agree that LinkedIn/ChatGPT style isn't the best route. We cringe on it too. We are experimenting to find a middle ground between what gets more reach, while not giving into the trending writing styles.Can I please get some more feedback from you?- would you prefer more technical details in this article?
- or just a change in the sentence structure that is more natural (like this response)?
- or both?replytux3 54 minutes ago
| root | parent | next [–]
The technical content is okay, but there's some fluff with a characteristic LLM signature that cheapens the whole thing. Instead of an article hand-crafted by human hands, it screams to the reader that they are currently reading slop.I would rather not read other people's slop. I could pass your article through an LLM myself, if I wanted that. Here's just one of the most tired snowclones that current LLMs love, everywhere in your content:>This wasn't a minor limitation; it was a fundamental capability gap>context-switch not just between data types, but between entirely different mental models of how to query data.>This wasn't something we asked them to do. They discovered that the query builder could now handle their complex cases, and they preferred it over raw SQL.>That's not just a technical achievement. That's validation that we finally understood the problem we were trying to solve.It wasn't just a minor stylistic issue; It was a signal to close the page.replyak_builds 12 minutes ago
| root | parent | next [–]
Feedback well taken! I'll update the articles soon and do better henceforth.replygiveita 32 minutes ago
| root | parent | prev | next [–]
Tropes in general I think become distracting. The ChatGPT style isn't bad in itself (just as one Giblhi cartoon isn't bad but 100000 are!)But you could survey more people as maybe it is just me!replyryoshu 8 hours ago
| prev | next [–]
I still struggle with ORMs. SQL is... declarative. If you're working with multiple RDBMSs, sure? Maybe I want my local dev to be sqlite and scaled be postgres? I've never run into that in production. A DSL on top of a DSL doesn't make a lot of sense.replyt-writescode 7 hours ago
| parent | next [–]
Hand-rolling SQL inside another programming language comes with some unpleasantness, like protecting against SQL injection and making sure the SQL is valid, especially when hand-constructing the query based on input parameters: “sort ascending? Descending? Filter all but things in this group? etc.”Parameter management in some languages are unpleasant, like how JDBC only has positional arguments; and any time you do string concat in a language, you start getting in danger of misformed SQL.Ultra basic ORMs, like Exposed (Kotlin), are well-tested frameworks that do exactly what I want. Want a single value in the =? Or want it to be an “in”? Or what if it’s null? Handled. No special string management. Want parameters? Handled.When I see pure ORM’d code, I can feel safe expecting it to be protected from injection and formatting issues. It’s reduced cognitive load and greater safety.When I see raw string SQL management, I have to put another layer of care and attention to try and make sure (and maybe still fail) there’s no application-crashing mistakes in that part of code.It’s kinda like working with typed and compiled code. Greater protection from error.replywebstrand 5 hours ago
| root | parent | next [–]
It sounds like you're describing a query builders which, unlike true ORMs, don't attempt to mask the object-relational boundary. They only help you build queries in a convenient way and sometimes type-safe way. Query builders are great.ORMs are not query builders. The problem with ORMs is that they hide the query logic from you. It's not clear what's getting joined in, how its getting joined in, or if its actually 1 or N queries. The further you get from a straight query builder, too, the fewer SQL features you have access to, such as parameterized joins, CTEs, window functions, etc. Sometimes you can hack those into the ORM, but often you have to resort to string concat and build the parameterized query and arguments manually.I've never used Exposed, but from what I can tell it's kind of a hybrid? the query builder parts look great, but I'd still be wary of the ORM parts.I've never had a good experience debugging performance issues in ORM-generated queries. Maybe I haven't used the right ones, but the libraries I've used have gone out of their way to hide how the query is actually being executed and only have obtuse levers to tweak that execution. Sure you can see the raw logs of what queries the ORM executed, but you can't easily figure out why its chosen a particular strategy. Or you can't easily make it stop using a pathological join ordering.replyandoando 4 hours ago
| root | parent | next [–]
I HATE ORMs. I end up spending an hour or two trying to figure out why something isnt working for what should be a simple query.Theyre also seem quite restrictive to what raw sql can do.replymonkeyelite 6 hours ago
| root | parent | prev | next [–]
You’re arguing against a straw man. All major language sql libraries are not based on string manipulation and provide things like escaping, arguments, etc out of the box.replykaoD 47 minutes ago
| root | parent | next [–]
Query builders are still an antipattern (what we traditionally think of when we say query builders) because they are still a DSL that (1) you have to learn along with SQL and (2) never map cleanly to actual SQL, so you always have to resort to `.raw` calls when you need anything more complex than a simple SELECT+JOIN.Even for simple SELECTs, I lost count of how many times I had to enable runtime DEBUG logging in my query builders to get a query that I can copy-paste into my DB client for debugging, data exploring, etc. I should be able to copy-paste my query from code and run it in `psql` with minimal changes.Raw SQL is the way to go[0]. Period. You just need a thin wrapper on top of it that adds escaping, arguments, type-safety and other QoL.[0] https://gajus.medium.com/stop-using-knex-js-and-earn-30-bf41...replyameliaquining 6 hours ago
| root | parent | prev | next [–]
Only for parameterization over scalar values. If you want to do any kind of composition more sophisticated than that, you're either stitching together strings or using some kind of more heavyweight abstraction like an ORM.replymonkeyelite 6 hours ago
| root | parent | next [–]
That’s because the composition is supposed to be inside sql. Views, functions, etc.This is another reason why the ORM is a leaky abstraction - it hides all the best features from you.replyameliaquining 6 hours ago
| root | parent | next [–]
I suspect the biggest reason those aren't more popular is that they usually have to be stored as state in the database, which isn't what you want when developing an application. You want all of your query logic to be versioned with your application code.replybranko_d 4 hours ago
| root | parent | next [–]
> You want all of your query logic to be versioned with your application code.SQL can be stored in version control just as well as any other code. This can include application-level queries as well as the DDL SQL which defines the actual structure of your database.It's sad that tooling for this kind of workflow doesn't seem to be particularly good across the board, Visual Studio being somewhat of an exception.replyameliaquining 4 hours ago
| root | parent | next [–]
The problem isn't version-controlling the SQL; it's making sure that, when a particular build of your app executes a query that calls out to a user-defined function, it uses the SQL function code from the same commit that the app itself was built from. Otherwise you have a potential source of version skew, and those are always really annoying and unpleasant to deal with.I think Postgres sort of supports this but it's really clunky, and also I think you'd have to run the function-creation code on every connection; I don't know whether that would create any performance problems.What does Visual Studio do?replysnuxoll 3 hours ago
| root | parent | next [–]
You just mentioned PostgreSQL, which, like pretty much every RDMBS sans MySQL, DB2/400, and maybe DB2/ZOS (never worked with the ZOS variant) supports schemas. If you need to worry about this, keep your tables that actually contain your data in one schema, then keep views, functions/stored procedures, etc. in separate schemas every time you make incompatible changes.The database is a separate component, the biggest mistake nearly every developer makes is trying to make a single application own it. Let me tell you, from experience, the chances that this one single application will be the only thing that every connects to your database past initial development is slim. "Oh, but we're doing microservices and everything only ever talks over HTTP or gRPC" - yeah, sure, and I don't have a backlog of tech debt a mile long.replymonkeyelite 6 hours ago
| root | parent | prev | next [–]
In most organizations a database is broader than any individual application - both in lifecycle and scope. So it makes sense that this state exists in a different way.I suspect it’s because people never learned to use them, but they did learn to use the ORM.replyameliaquining 4 hours ago
| root | parent | next [–]
The textbooks all say that, but is it really true in practice? I suspect it's a bit of holdover conventional wisdom from an earlier era of software. Usually, when I've created a database for a particular app, it was never used by anything else besides that app (and manual queries, for which versioning is mostly not relevant).You might choose to have a set of views and functions that are versioned separately from your app, for the same reasons you might choose to set up a microservice. But as with microservices, it should be a deliberate decision that you make because you're getting something out of it that outweighs the complexity costs and version-skew headaches; it should not be the default way to do composition.replybranko_d 5 hours ago
| root | parent | prev | next [–]
> Only for parameterization over scalar values.ADO.NET has full support for table-valued parameters.replyameliaquining 4 hours ago
| root | parent | next [–]
That's part of .NET Framework and therefore legacy, right? Do the database libraries from recent versions of .NET do this?In any case, it's just one framework; previous comment said "all major languages". And it's useful to be able to abstract and compose over expressions and predicates and such, not just data values, which this still doesn't help with.replynever_inline 7 hours ago
| parent | prev | next [–]
How do you do conditional filters in pure SQL from a backend Java / Python app, without doing string concatenation?Not a fan of all the proxy object circus ORMs do but I'd leave row-> domain object mapping and filter building to some library. Sweet spot is probably something akin to Android Room / Micronaut Data JDBC.replyminitech 7 hours ago
| root | parent | next [–]
Query builders that operate at the SQL level. (A popular example of that in Python is SQLAlchemy Core, but there are better ways to do it, especially in better-typed languages.)replyfoobazgt 6 hours ago
| root | parent | prev | next [–]
JOOQ (http://jooq.org) is pretty fantastic for this, and it's my go-to for working with RDBMs' on the JVM. It provides a DSL-like API that lets you write pretty much any SQL you need in a type-safe way (without string concatenation).replycrazygringo 7 hours ago
| root | parent | prev | next [–]
What's wrong with string concatenation?replyt-writescode 7 hours ago
| root | parent | next [–]
Simpler SQL injection risk and more testing to make sure all potential branching paths don’t result in invalid SQL.replywebstrand 6 hours ago
| root | parent | next [–]
There's zero danger of sql injection so long as everything is being passed by parameters. You just concatenate placeholders when you need string concatenation to build the query.replycrazygringo 5 hours ago
| root | parent | next [–]
Exactly this.And if you're testing, you've got to test every query combination anyways. It's not just syntax that can be wrong, but logic and performance.replypaulddraper 7 hours ago
| root | parent | prev | next [–]
String concatenationreplyXss3 7 hours ago
| root | parent | next [–]
No, we must build 16 more layers of pointless abstraction in a new DSL.replychillfox 7 hours ago
| parent | prev | next [–]
My main issue with ORMs is they always end up being just another thing to learn, adding needless complexity. They are not an alternative to SQL as you always end up having to understand what kind of SQL they create and how it works for either performance or complex queries.replydec0dedab0de 7 hours ago
| parent | prev | next [–]
I just want to write one language at a time if I can.
I like sql when querying directly, almost as a UI of sorts, but it’s not my favorite when I am just trying to get my code to work, and the database is a relatively minor detail.replyflowerthoughts 3 hours ago
| prev | next [–]
One of my guiding principles is "avoid indirection unless you add abstraction." If what you're doing is a query language, then keeping that transparent and using existing languages is a good idea, unless you can motivate a new language with a new mental model. E.g. it might be better to write an SQL query validator than a DSL.replyest 6 hours ago
| prev | next [–]
> Stop making decisions for users.yes! please stop making webpages background dark. It's a terrible design for ppl with astigmatism like me...replyak_builds 3 hours ago
| parent | next [–]
Thank you for educating me on astigmatism. I wasn't aware of the condition.We are revamping the design. I'll ensure I understand more about this and make it more accessible.Devs seem to prefer dark theme across the brand (eg Supabase, Linear). Hence, the current choice.replyprpl 5 hours ago
| prev | next [–]
Salesforce’s SOQL, like was mentioned with Jira’s JQL, also
handles this type of thing _okay_ without explicit joins.I think “SQL is the interface” even for telemtry is the thing that truly makes sense, but it is messy with logs compared to splunk for examplereplyshakna 4 hours ago
| parent | next [–]
SoQL's lack of joins and subqueries makes it a real pain in my life. `having` and `group by` are not enough when doing a lot of things - like confirming data migration of 40m objects.Can't do a query builder in one step, or must write Apex.replyankitnayan 1 hour ago
| root | parent | next [–]
and here query builder helps by making it earier to do cross-signal joins and subqueries. I see that is upcoming in SigNoz https://signoz.io/blog/query-builder-v5/#what-we-couldnt-shi...replyfoxglacier 33 minutes ago
| prev | next [–]
> hide complexity to "simplify" the experienceThis is a chronic problem in software. What I do instead is either omit the complexity or make it as visible as everything else. If it's not worth making it discoverable, it's not worth having. If you omit it, you get customer feedback about its importance instead of them struggling in silence.replygm678 4 hours ago
| prev | next [–]
I hate getting that 'is this LLM output?' feeling halfway through so many articles these days. The article is good but sentences like "This wasn't a minor limitation; it was a fundamental capability gap." are painful to read.> Currently, logs and traces live in separate worlds. You can see that a trace has an error, and you can see related logs, but you can't query them together.I've looked into SigNoz a few times but still using Grafana. The former does look promising, and features like this would start to make the case for maybe switching.replyankitnayan 1 hour ago
| parent | next [–]
You might also like the interactive dashboard feauture that was released in the recent launch week https://www.youtube.com/watch?v=YQTQXq0F5Iw&ab_channel=SigNo...replymonkeyelite 6 hours ago
| prev [–]
Is it actually hard to build a DSL for the kind of query’s they are talking about? Seems like it would be a 50 line SICP exercise.replyameliaquining 6 hours ago
| parent [–]
Conveniently, it's open core, so you can look: https://github.com/SigNoz/signoz/tree/main/pkg/querybuilderSeems to be 3978 lines of Go at present.replyecshafer 5 hours ago
| root | parent [–]
Go is pretty wordy, so 50 lines of scheme would be a bit of an exaggeration, but a good enough schemer could probably get it down therereply
Guidelines | FAQ | Lists | API | Security | Legal | Apply to YC | Contact
Search:
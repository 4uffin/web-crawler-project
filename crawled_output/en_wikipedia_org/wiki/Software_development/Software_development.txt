Software development - Wikipedia
Jump to content
Main menu
Main menu
move to sidebar
hide
Navigation
Main pageContentsCurrent eventsRandom articleAbout WikipediaContact us
Contribute
HelpLearn to editCommunity portalRecent changesUpload fileSpecial pages
Search
Search
Appearance
Donate
Create account
Log in
Personal tools
Donate Create account Log in
Pages for logged out editors learn more
ContributionsTalk
Contents
move to sidebar
hide
(Top)
1
Methodologies
2
Steps
Toggle Steps subsection
2.1
Feasibility
2.2
Analysis
2.3
Design
2.4
Programming
2.5
Testing
2.6
Production
3
Workers
4
Models and tools
Toggle Models and tools subsection
4.1
Computer-aided software engineering
4.2
Documentation
4.3
Effort estimation
4.4
Integrated development environment
4.5
Version control
4.6
View model
4.7
Fitness functions
5
Intellectual property
6
References
7
Further reading
8
External links
Toggle the table of contents
Software development
52 languages
AfrikaansالعربيةAzərbaycancaবাংলাБеларускаяБългарскиCatalàČeštinaChiTumbukaDanskDeutschEestiEspañolEuskaraفارسیFrançais한국어हिन्दीIdoBahasa IndonesiaItalianoעבריתJawaLatviešuLietuviųMagyarമലയാളംBahasa MelayuМонголမြန်မာဘာသာ日本語Norsk bokmålPolskiPortuguêsQaraqalpaqshaRomânăRuna SimiРусскийShqipSimple EnglishکوردیСрпски / srpskiSuomiSvenskaதமிழ்TürkçeУкраїнськаاردوTiếng Việt粵語中文ⵜⴰⵎⴰⵣⵉⵖⵜ ⵜⴰⵏⴰⵡⴰⵢⵜ
Edit links
ArticleTalk
English
ReadEditView history
Tools
Tools
move to sidebar
hide
Actions
ReadEditView history
General
What links hereRelated changesUpload filePermanent linkPage informationCite this pageGet shortened URLDownload QR code
Print/export
Download as PDFPrintable version
In other projects
Wikimedia CommonsWikidata item
Appearance
move to sidebar
hide
From Wikipedia, the free encyclopedia
Creation and maintenance of software
Part of a series onSoftware development
Core activities
Data modeling
Processes
Requirements
Design
Construction
Engineering
Testing
Debugging
Deployment
Maintenance
Paradigms and models
Agile
Cleanroom
Incremental
Prototyping
Spiral
V model
Waterfall
Methodologies and frameworks
ASD
DAD
DevOps
DSDM
FDD
IID
Kanban
Lean SD
LeSS
MDD
MSF
PSP
RAD
RUP
SAFe
Scrum
SEMAT
TDD
TSP
UP
XP
Supporting disciplines
Configuration management
Deployment management
Documentation
Project management
Quality assurance
User experience
Practices
ATDD
BDD
CCO
CD
CI
DDD
PP
SBE
Stand-up
TDD
Tools
Build automation
Compiler
Debugger
GUI builder
IDE
Infrastructure as code
Profiler
Release automation
UML Modeling
Standards and bodies of knowledge
CMMI
IEEE standards
IREB
ISO 9001
ISO/IEC standards
ITIL
OMG
PMBOK
SWEBOK
Glossaries
Artificial intelligence
Computer science
Electrical and electronics engineering
Outlines
Outline of software development
Outline of the C programming language
vte
Software development is the process of designing and implementing a software solution to satisfy a user. The process is more encompassing than programming, writing code, in that it includes conceiving the goal, evaluating feasibility, analyzing requirements, design, testing and release. The process is part of software engineering which also includes organizational management, project management, configuration management and other aspects.[1]
Software development involves many skills and job specializations including programming, testing, documentation, graphic design, user support, marketing, and fundraising.
Software development involves many tools including: compiler, integrated development environment (IDE), version control, computer-aided software engineering, and word processor.
The details of the process used for a development effort vary. The process may be confined to a formal, documented standard, or it can be customized and emergent for the development effort. The process may be sequential, in which each major phase (i.e., design, implement, and test) is completed before the next begins, but an iterative approach – where small aspects are separately designed, implemented, and tested – can reduce risk and cost and increase quality.
Methodologies[edit]
Main article: Software development methodology
Flowchart of the evolutionary prototyping model, an iterative development model[2]
Each of the available methodologies is best suited to specific kinds of projects, based on various technical, organizational, project, and team considerations.[3]
The simplest methodology is the "code and fix", typically used by a single programmer working on a small project. After briefly considering the purpose of the program, the programmer codes it and runs it to see if it works. When they are done, the product is released. This methodology is useful for prototypes but cannot be used for more elaborate programs.[4]
In the top-down waterfall model, feasibility, analysis, design, development, quality assurance, and implementation occur sequentially in that order. This model requires one step to be complete before the next begins, causing delays, and makes it impossible to revise previous steps if necessary.[5][6][7]
With iterative processes these steps are interleaved with each other for improved flexibility, efficiency, and more realistic scheduling. Instead of completing the project all at once, one might go through most of the steps with one component at a time. Iterative development also lets developers prioritize the most important features, enabling lower priority ones to be dropped later on if necessary.[6][8] Agile is one popular method, originally intended for small or medium sized projects, that focuses on giving developers more control over the features that they work on to reduce the risk of time or cost overruns.[9] Derivatives of agile include extreme programming and Scrum.[9] Open-source software development typically uses agile methodology with concurrent design, coding, and testing, due to reliance on a distributed network of volunteer contributors.[10]
Beyond agile, some companies integrate information technology (IT) operations with software development, which is called DevOps or DevSecOps including computer security.[11] DevOps includes continuous development, testing, integration of new code in the version control system, deployment of the new code, and sometimes delivery of the code to clients.[12] The purpose of this integration is to deliver IT services more quickly and efficiently.[11]
Another focus in many programming methodologies is the idea of trying to catch issues such as security vulnerabilities and bugs as early as possible (shift-left testing) to reduce the cost of tracking and fixing them.[13]
In 2009, it was estimated that 32% of software projects were delivered on time and on budget, and with full functionality. An additional 44% were delivered, but were missing at least one of their features. The remaining 24% were cancelled before release.[14]
Steps[edit]
Software development life cycle refers to the systematic process of developing applications.[15]
Feasibility[edit]
The sources of ideas for software products are plentiful. These ideas can come from market research, including the demographics of potential new customers, existing customers, sales prospects who rejected the product, other internal software development staff, or a creative third party. Ideas for software products are usually first evaluated by marketing personnel for economic feasibility, fit with existing channels of distribution, possible effects on existing product lines, required features, and fit with the company's marketing objectives. In the marketing evaluation phase, the cost and time assumptions are evaluated.[16] The feasibility analysis estimates the project's return on investment, its development cost and timeframe. Based on this analysis, the company can make a business decision to invest in further development.[17] After deciding to develop the software, the company is focused on delivering the product at or below the estimated cost and time, and with a high standard of quality (i.e., lack of bugs) and the desired functionality. Nevertheless, most software projects run late, and sometimes compromises are made in features or quality to meet a deadline.[18]
Analysis[edit]
Software analysis begins with a requirements analysis to capture the business needs of the software.[19] Challenges for the identification of needs are that current or potential users may have different and incompatible needs, may not understand their own needs, and change their needs during the process of software development.[20] Ultimately, the result of analysis is a detailed specification for the product that developers can work from. Software analysts often decompose the project into smaller objects, components that can be reused for increased cost-effectiveness, efficiency, and reliability.[19] Decomposing the project may enable a multi-threaded implementation that runs significantly faster on multiprocessor computers.[21]
During the analysis and design phases of software development, structured analysis is often used to break down the customer's requirements into pieces that can be implemented by software programmers.[22] The underlying logic of the program may be represented in data-flow diagrams, data dictionaries, pseudocode, state transition diagrams, and/or entity relationship diagrams.[23] If the project incorporates a piece of legacy software that has not been modeled, this software may be modeled to help ensure it is correctly incorporated with the newer software.[24]
Design[edit]
Main article: software design
Design involves choices about the implementation of the software, such as which programming languages and database software to use, or how the hardware and network communications will be organized. Design may be iterative with users consulted about their needs in a process of trial and error. Design often involves people who are expert in aspects such as database design, screen architecture, and the performance of servers and other hardware.[19] Designers often attempt to find patterns in the software's functionality to spin off distinct modules that can be reused with object-oriented programming. An example of this is the model–view–controller, an interface between a graphical user interface and the backend.[25]
Programming[edit]
Main article: computer programming
The central feature of software development is creating and understanding the software that implements the desired functionality.[26] There are various strategies for writing the code. Cohesive software has various components that are independent from each other.[19] Coupling is the interrelation of different software components, which is viewed as undesirable because it increases the difficulty of maintenance.[27] Often, software programmers do not follow industry best practices, resulting in code that is inefficient, difficult to understand, or lacking documentation on its functionality.[28] These standards are especially likely to break down in the presence of deadlines.[29] As a result, testing, debugging, and revising the code become much more difficult. Code refactoring, for example, adding more comments to the code, is a solution to improve the understandability of the code.[30]
Testing[edit]
Main article: software testing
Testing is the process of ensuring that the code executes correctly and without errors. Debugging is performed by each software developer on their own code to confirm that the code does what it is intended to. In particular, it is crucial that the software executes on all inputs, even if the result is incorrect.[31] Code reviews by other developers are often used to scrutinize new code added to the project, and according to some estimates dramatically reduce the number of bugs persisting after testing is complete.[32] Once the code has been submitted, quality assurance – a separate department of non-programmers for most large companies – test the accuracy of the entire software product. Acceptance tests derived from the original software requirements are a popular tool for this.[31] Quality testing also often includes stress and load checking (whether the software is robust to heavy levels of input or usage), integration testing (to ensure that the software is adequately integrated with other software), and compatibility testing (measuring the software's performance across different operating systems or browsers).[31] When tests are written before the code, this is called test-driven development.[33]
Production[edit]
See also: Software release life cycle
Production is the phase in which software is deployed to the end user.[34] During production, the developer may create technical support resources for users[35][34] or a process for fixing bugs and errors that were not caught earlier. There might also be a return to earlier development phases if user needs changed or were misunderstood.[34]
Workers[edit]
Software development is performed by software developers, usually working on a team. Efficient communications between team members is essential to success. This is more easily achieved if the team is small, used to working together, and located near each other.[36] Communications also help identify problems at an earlier stage of development and avoid duplicated effort. Many development projects avoid the risk of losing essential knowledge held by only one employee by ensuring that multiple workers are familiar with each component.[37] Software development involves professionals from various fields, not just software programmers but also product managers who set the strategy and roadmap for the product,[38] individuals specialized in testing, documentation writing, graphic design, user support, marketing, and fundraising. Although workers for proprietary software are paid, most contributors to open-source software are volunteers.[39] Alternately, they may be paid by companies whose business model does not involve selling the software, but something else – such as services and modifications to open source software.[40]
Models and tools[edit]
Computer-aided software engineering[edit]
Computer-aided software engineering (CASE) is tools for the partial automation of software development.[41] CASE enables designers to sketch out the logic of a program, whether one to be written, or an already existing one to help integrate it with new code or reverse engineer it (for example, to change the programming language).[42]
Documentation[edit]
Main article: Software documentation
Documentation comes in two forms that are usually kept separate – one intended for software developers, and another made available to the end user to help them use the software.[43][44] Most developer documentation is in the form of code comments for each file, class, and method that cover the application programming interface (API)—how the piece of software can be accessed by another—and often implementation details.[45] This documentation is helpful for new developers to understand the project when they begin working on it.[46] In agile development, the documentation is often written at the same time as the code.[47] User documentation is more frequently written by technical writers.[48]
Effort estimation[edit]
Main article: Software development effort estimation
Accurate estimation is crucial at the feasibility stage and in delivering the product on time and within budget. The process of generating estimations is often delegated by the project manager.[49] Because the effort estimation is directly related to the size of the complete application, it is strongly influenced by the addition of features in the requirements—the more requirements, the higher the development cost. Aspects not related to functionality, such as the experience of the software developers and code reusability, are also essential to consider in estimation.[50] As of 2019[update], most of the tools for estimating the amount of time and resources for software development were designed for conventional applications and are not applicable to web applications or mobile applications.[51]
Integrated development environment[edit]
Anjuta, a C and C++ IDE for the GNOME environment
An integrated development environment (IDE) supports software development with enhanced features compared to a simple text editor.[52] IDEs often include automated compiling, syntax highlighting of errors,[53] debugging assistance,[54] integration with version control, and semi-automation of tests.[52]
Version control[edit]
Main article: Version control
Version control is a popular way of managing changes made to the software. Whenever a new version is checked in, the software saves a backup of all modified files. If multiple programmers are working on the software simultaneously, it manages the merging of their code changes. The software highlights cases where there is a conflict between two sets of changes and allows programmers to fix the conflict.[55]
View model[edit]
The TEAF Matrix of Views and Perspectives
A view model is a framework that provides the viewpoints on the system and its environment, to be used in the software development process. It is a graphical representation of the underlying semantics of a view.
The purpose of viewpoints and views is to enable human engineers to comprehend very complex systems and to organize the elements of the problem around domains of expertise. In the engineering of physically intensive systems, viewpoints often correspond to capabilities and responsibilities within the engineering organization.[56]
Fitness functions[edit]
Fitness functions are automated and objective tests to ensure that the new developments do not deviate from the established constraints, checks and compliance controls.[57]
Intellectual property[edit]
Intellectual property can be an issue when developers integrate open-source code or libraries into a proprietary product, because most open-source licenses used for software require that modifications be released under the same license. As an alternative, developers may choose a proprietary alternative or write their own software module.[58]
References[edit]
^ Dooley 2017, p. 1.
^ Dooley 2017, p. 12.
^ System Development Methodologies for Web-Enabled E-Business: A Customization Framework
Linda V. Knight (DePaul University, USA), Theresa A. Steinbach (DePaul University, USA), and Vince Kellen (Blue Wolf, USA)
^ Dooley 2017, pp. 8–9.
^ Dooley 2017, p. 9.
^ a b Langer 2016, pp. 2–3, 5–6.
^ Tucker, Morelli & de Silva 2011, p. 8.
^ Dooley 2017, p. 11.
^ a b Dooley 2017, p. 13.
^ Tucker, Morelli & de Silva 2011, pp. 41–42.
^ a b Vishnu 2019, pp. 1–2.
^ Laukkanen, Eero; Itkonen, Juha; Lassenius, Casper (2017). "Problems, causes and solutions when adopting continuous delivery—A systematic literature review". Information and Software Technology. 82: 55–79. doi:10.1016/j.infsof.2016.10.001.
^ Winters, Manshreck & Wright 2020, p. 17.
^ Tucker, Morelli & de Silva 2011, p. 6.
^ Saif 2019, pp. 46–47.
^ Morris 2001, p. 1.10.
^ Langer 2016, p. 7.
^ Dooley 2017, pp. 3, 8.
^ a b c d Langer 2016, p. 8.
^ Langer 2016, pp. 2–3.
^ Dooley 2017, pp. 193–194.
^ Langer 2016, pp. 103–104.
^ Langer 2016, pp. 117, 127, 131, 137, 141.
^ Langer 2016, p. 106.
^ Dooley 2017, p. 142.
^ Tucker, Morelli & de Silva 2011, p. 31.
^ Langer 2016, pp. 8–9.
^ Tucker, Morelli & de Silva 2011, pp. 31–32.
^ Tucker, Morelli & de Silva 2011, pp. 34–35.
^ Tucker, Morelli & de Silva 2011, pp. 31–32, 35.
^ a b c Langer 2016, p. 9.
^ Dooley 2017, p. 272.
^ Tucker, Morelli & de Silva 2011, p. 9.
^ a b c Langer 2016, p. 10.
^ Tucker, Morelli & de Silva 2011, p. 37.
^ Dooley 2017, p. 2.
^ Winters, Manshreck & Wright 2020, pp. 30–31.
^ "What Does a Product Manager Do? And How to Become One". Coursera. 21 January 2025. Retrieved 5 May 2025.
^ Tucker, Morelli & de Silva 2011, p. 7.
^ Tucker, Morelli & de Silva 2011, pp. 14–15.
^ Langer 2016, p. 22.
^ Langer 2016, pp. 108–110, 206.
^ Tucker, Morelli & de Silva 2011, p. 243.
^ Winters, Manshreck & Wright 2020, p. 192.
^ Winters, Manshreck & Wright 2020, pp. 193–195.
^ Tucker, Morelli & de Silva 2011, p. 143.
^ Tucker, Morelli & de Silva 2011, p. 144.
^ Winters, Manshreck & Wright 2020, p. 204.
^ Saif 2019, pp. 50–51.
^ Saif 2019, pp. 52–53.
^ Saif 2019, p. 45.
^ a b Tucker, Morelli & de Silva 2011, p. 68.
^ Dooley 2017, p. 236.
^ Dooley 2017, p. 239.
^ Dooley 2017, pp. 246–247.
^ Edward J. Barkmeyer ea (2003). Concepts for Automating Systems Integration Archived 25 January 2017 at the Wayback Machine NIST 2003.
^ Fundamentals of Software Architecture: An Engineering Approach. O'Reilly Media. 2020. ISBN 978-1492043454.
^ Langer 2016, pp. 44–45.
Further reading[edit]
Conde, Dan (2002). Software Product Management: Managing Software Development from Idea to Product to Marketing to Sales. Aspatore Books. ISBN 1587622025.
Davis, A. M. (2005). Just enough requirements management: Where software development meets marketing. Dorset House Publishing Company, Incorporated. ISBN 0932633641.
Dooley, John F. (2017). Software Development, Design and Coding: With Patterns, Debugging, Unit Testing, and Refactoring. Apress. ISBN 978-1-4842-3153-1.
Kit, Edward (1992). Software Testing in The Real World. Addison-Wesley Professional. ISBN 0201877562.
Hasted, Edward (2005). Software That Sells: A Practical Guide to Developing and Marketing Your Software Project. Wiley Publishing. ISBN 0764597833.
Hohmann, Luke (2003). Beyond Software Architecture: Creating and Sustaining Winning Solutions. Addison-Wesley Professional. ISBN 0201775948.
Horch, John W. (March 1995). "Two Orientations On How To Work With Objects". IEEE Software. 12 (2): 117–118. ProQuest 215832531.
Langer, Arthur M. (2016). Guide to Software Development: Designing and Managing the Life Cycle. Springer. ISBN 978-1-4471-6799-0.
McCarthy, Jim (1995). Dynamics of Software Development. Microsoft Press. ISBN 1556158238.
Morris, Joseph M. (2001). Software industry accounting (2nd ed.). John Wiley & Sons. OCLC 53863959.
Rittinghouse, John (2003). Managing Software Deliverables: A Software Development Management Methodology. Digital Press. ISBN 155558313X.
Saif, Syed Mohsin (2019). "Software Effort Estimation for Successful Software Application Development". In Vishnu, Pendyala (ed.). Tools and Techniques for Software Development in Large Organizations: Emerging Research and Opportunities: Emerging Research and Opportunities. IGI Global. pp. 45–97. ISBN 978-1-7998-1865-6.
Tucker, Allen; Morelli, Ralph; de Silva, Chamindra (2011). Software Development: An Open Source Approach. CRC Press. ISBN 978-1-4398-8460-7.
Vishnu, Pendyala (2019). "Evolution of Integration, Build, Test, and Release Engineering Into DevOps and to DevSecOps". In Vishnu, Pendyala (ed.). Tools and Techniques for Software Development in Large Organizations: Emerging Research and Opportunities: Emerging Research and Opportunities. IGI Global. pp. 1–20. ISBN 978-1-7998-1865-6.
Wiegers, Karl E. (2005). More About Software Requirements: Thorny Issues and Practical Advice. Microsoft Press. ISBN 0735622671.
Winters, Titus; Manshreck, Tom; Wright, Hyrum (2020). Software Engineering at Google: Lessons Learned from Programming Over Time. O'Reilly Media, Inc. ISBN 978-1-4920-8276-7.
Wysocki, Robert K. (2006). Effective Software Project Management. Wiley. ISBN 0764596365.
External links[edit]
Media related to Software development at Wikimedia Commons
vteSoftware engineeringFields
Computer programming
DevOps
Empirical software engineering
Experimental software engineering
Formal methods
Requirements engineering
Search-based software engineering
Site reliability engineering
Social software engineering
Software deployment
Software design
Software maintenance
Software testing
Systems analysis
Concepts
Abstraction
CI/CD
Compatibility
Backward compatibility
Compatibility layer
Compatibility mode
Forward compatibility
Software incompatibility
Component-based software engineering
Data modeling
Enterprise architecture
Functional specification
Modeling language
Programming paradigm
Software
Software archaeology
Software architecture
Software configuration management
Software development process/methodology
Software quality
Software quality assurance
Software system
Software verification and validation
Structured analysis
Essential analysis
Orientations
Agile
Aspect-oriented
Object orientation
Ontology
SDLC
Service orientation
ModelsDevelopmental
Agile
EUP
Executable UML
Incremental model
Iterative model
Prototype model
RAD
Scrum
Spiral model
UP
V-model
Waterfall model
XP
Model-driven engineering
Round-trip engineering
Other
CMMI
Data model
ER model
Function model
Information model
Metamodeling
Object model
SPICE
Systems model
View model
Languages
IDEF
SysML
UML
USL
Related fields
Computer engineering
Computer science
Information science
Project management
Risk management
Systems engineering
Category
Commons
vteComputer scienceNote: This template roughly follows the 2012 ACM Computing Classification System.Hardware
Printed circuit board
Peripheral
Integrated circuit
Very-large-scale integration
System on a chip (SoC)
Energy consumption (green computing)
Electronic design automation
Hardware acceleration
Processor
Size / Form
Computer systems organization
Computer architecture
Computational complexity
Dependability
Embedded system
Real-time computing
Cyber-physical system
Fault tolerance
Wireless sensor network
Networks
Network architecture
Network protocol
Network components
Network scheduler
Network performance evaluation
Network service
Software organization
Interpreter
Middleware
Virtual machine
Operating system
Software quality
Software notations and tools
Programming paradigm
Programming language
Compiler
Domain-specific language
Modeling language
Software framework
Integrated development environment
Software configuration management
Software library
Software repository
Software development
Control variable
Software development process
Requirements analysis
Software design
Software construction
Software deployment
Software engineering
Software maintenance
Programming team
Open-source model
Theory of computation
Model of computation
Stochastic
Formal language
Automata theory
Computability theory
Computational complexity theory
Logic
Semantics
Algorithms
Algorithm design
Analysis of algorithms
Algorithmic efficiency
Randomized algorithm
Computational geometry
Mathematics of computing
Discrete mathematics
Probability
Statistics
Mathematical software
Information theory
Mathematical analysis
Numerical analysis
Theoretical computer science
Information systems
Database management system
Information storage systems
Enterprise information system
Social information systems
Geographic information system
Decision support system
Process control system
Multimedia information system
Data mining
Digital library
Computing platform
Digital marketing
World Wide Web
Information retrieval
Security
Cryptography
Formal methods
Security hacker
Security services
Intrusion detection system
Hardware security
Network security
Information security
Application security
Human-centered computing
Interaction design
Augmented reality
Virtual reality
Social computing
Ubiquitous computing
Visualization
Accessibility
Human–computer interaction
Mobile computing
Concurrency
Concurrent computing
Parallel computing
Distributed computing
Multithreading
Multiprocessing
Artificial intelligence
Natural language processing
Knowledge representation and reasoning
Computer vision
Automated planning and scheduling
Search methodology
Control method
Philosophy of artificial intelligence
Distributed artificial intelligence
Machine learning
Supervised learning
Unsupervised learning
Reinforcement learning
Multi-task learning
Cross-validation
Graphics
Animation
Rendering
Photograph manipulation
Graphics processing unit
Image compression
Solid modeling
Applied computing
Quantum computing
E-commerce
Enterprise software
Computational mathematics
Computational physics
Computational chemistry
Computational biology
Computational social science
Computational engineering
Differentiable computing
Computational healthcare
Digital art
Electronic publishing
Cyberwarfare
Electronic voting
Video games
Word processing
Operations research
Educational technology
Document management
Category
Outline
Glossaries
Authority control databases InternationalGNDNationalUnited StatesJapanSpainIsraelOtherYale LUX
Retrieved from "https://en.wikipedia.org/w/index.php?title=Software_development&oldid=1311901273"
Categories: Software developmentSoftware project managementComputer occupationsProduct developmentHidden categories: Webarchive template wayback linksArticles with short descriptionShort description is different from WikidataUse dmy dates from March 2024Use British English from December 2021All Wikipedia articles written in British EnglishArticles containing potentially dated statements from 2019All articles containing potentially dated statementsCommons category link is on Wikidata
This page was last edited on 17 September 2025, at 14:58 (UTC).
Text is available under the Creative Commons Attribution-ShareAlike 4.0 License;
additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy. Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a non-profit organization.
Privacy policy
About Wikipedia
Disclaimers
Contact Wikipedia
Code of Conduct
Developers
Statistics
Cookie statement
Mobile view
Search
Search
Toggle the table of contents
Software development
52 languages
Add topic
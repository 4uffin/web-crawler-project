Safe C++ proposal is not being continued | Hacker NewsHacker Newsnew | past | comments | ask | show | jobs | submitloginSafe C++ proposal is not being continued (sibellavia.lol)102 points by charles_irl 6 hours ago
| hide | past | favorite | 70 comments
the_black_hand 0 minutes ago
| next [–]
"If you want to write like Rust, just write Rust".
Exactly. No reason not to. RIP cppreplytialaramex 5 hours ago
| prev | next [–]
I am actually much more pessimistic about Profiles than Simone.Regardless of the technology the big thing Rust has that C++ does not is safety culture, and that's dominant here. You could also see at the 2024 "Fireside chat" at CppCon that this isn't likely to change any time soon.The profiles technology isn't very good. But that's insignificant next to the culture problem, once you decided to make the fifteen minute bagpipe dirge your lead single it doesn't really matter whether you use the colored vinyl.replyAlotOfReading 4 hours ago
| parent | next [–]
It doesn't show up in the online videos, but there was a huge contingent of people at that fireside chat wanting a reasonable safety story for C++. The committee simply doesn't have representation from those people and don't seem to understand why it's an existential risk to the language community. The delivery timelines are so long here that anything not standardized soon isn't going to arrive for a decade or more. That's all the time in the world for Rust (or even Zig) to break down the remaining barriers.Profiles and sanitizers just aren't sufficient.replyIshKebab 4 hours ago
| root | parent | next [–]
Yeah because the committee is now people that a) really love C++, and b) don't care enough about safety to use Rust instead.I think there are plenty of people that must use C++ due to legacy, management or library reasons and they care about safety. But those people aren't going to join language committees.replypizlonator 3 hours ago
| parent | prev | next [–]
> The profiles technology isn't very good.Can you be very specific about why?Here's the argument for why profiles might work: with all of the profiles enabled, you are only allowed to use the safe subset of C++ and all of the unsafe stuff is hidden behind APIs whose implementations don't have those profiles enabled. Those projects that enable all profiles by default effectively get Swift-like or Rust-like protection.Like, you could force all array operations to use C++ stdlib primitives, enable full hardening of the stdlib, and then have bounds safety.And you could force all lifetime operations to use C++ stdlib refcounting primitives, and then have lifetime safety in a Swift-like way (i.e. eager refcounting everywhere).I can imagine how this falls over but then it might just be a matter of engineering to make it not fall over.(I'm playing devils advocate a bit since I prefer Fil-C++.)replytialaramex 1 hour ago
| root | parent | next [–]
Yes I can be specific.Firstly, you need composition. Rust's safety composes. The safe Rust library for farm animals from Geoff, the safe Rust library for cooking recipes by Alice and the safe Rust library for web server by Bert together with my safe program code adds up to my safe Rust farm foods web site.By having N profiles, where N is intended to be at least five and might grow arbitrarily and be user extensible, C++ guarantees it cannot deliver composition this way.Maybe they can define some sort of composition and maybe everybody will ship software which conforms to that definition and so eventually they get composition, that's not there today, so it's just a giant unknown at best.Secondly, of the profiles described so far, most of them are just solving parts of the single overarching problem Rust addresses, for the serial case. So if they ship that, which already involves some amount of new work yet to be finished, you need all of those profiles to get to only partial memory safety.Which comes to the third part. Once you start down this path, as they found, you realise you actually want a borrowck. You won't call it that of course, because that would be embarrassing. But you'll need to track reference lifetimes and you'll need annotation and you end up building most of the stuff you insisted you didn't want. For now, you can handwave, this is an unsolved static analysis problem. Well, not so much unsolved as you know the solution and you don't like it.Your idea to do the reference counting everywhere is not something WG21 has looked at, I think the perf cost is sufficiently bad that they won't even glance at it. They're also not going to ship a GC.Finally though, C++ is a concurrent language. It has a whole memory model which doesn't even make sense if you aren't thinking about concurrency. But to deliver concurrent memory safety without Fil-C's overheads you would want... well, Rust's Send and Sync traits, which sure enough have eerie twins in the Safe C++ proposal.
No attempt to solve this is even hinted at in the current profiles proposal, and they would need to work one out and if it's not Send + Sync again they'd need to prove it is correct.replypizlonator 1 hour ago
| root | parent | next [–]
I think the point is that folks will incrementally move their code towards having all profiles enabled, and that's sort of fundamental if the goal is to give folks with C++ codebases an incremental path to safety. So I don't buy your first and second points.> Which comes to the third part. Once you start down this path, as they found, you realise you actually want a borrowck.That's a bold statement. It might be true for some very loose definition of "borrow checker". See the super simple static analysis that WebKit uses (that presentation is now linked in at least two places on this HN discussion, so I won't link it again).> Your idea to do the reference counting everywhere is not something WG21 has looked at, I think the perf cost is sufficiently bad that they won't even glance at it. They're also not going to ship a GC.The point isn't to have ref counting on every pointer at the language level, but rather: if your prevent folks from calling `delete` directly (as one of the profiles does) then you're effectively forcing folks to use smart pointers.Reference counting that happens by smart pointers is something that they would ship. We know this because it's already happened.I imagine this would really mean that some references are ref counted (if you use shared_ptr or similar) while other references use some other policy.> Finally though, C++ is a concurrent language. It has a whole memory model which doesn't even make sense if you aren't thinking about concurrency. But to deliver concurrent memory safety without Fil-C's overheads you would want... well, Rust's Send and Sync traitsYeah, this might be an area where they leave a hole. Like, you might have reference counting that is only partially thread safe:- The refcount of any object is atomic.- The smart pointer itself is racy. So, racing on pointers can pop the protections.If they got that far, then that wouldn't be so bad. The marginal safety advantage of Rust would be very slim at that point.replyIAmLiterallyAB 3 hours ago
| root | parent | prev | next [–]
My limited understanding is. There is no safe subset (That's what was just discontinued, profiles are the alternative.)And C++ code simply doesn't have the necessary info to make safety decisions. Sean explains it better than I can https://www.circle-lang.org/draft-profiles.htmlreplysteveklabnik 2 hours ago
| root | parent | prev | next [–]
> with all of the profiles enabled, you are only allowed to use the safe subset of C++ and all of the unsafe stuff is hidden behind APIs whose implementations don't have those profiles enabled.This is not the goal of profiles. It’s to be “good enough.” Guaranteed safety isn’t in the cards.replypizlonator 1 hour ago
| root | parent | next [–]
> This is not the goal of profiles. It’s to be “good enough.” Guaranteed safety isn’t in the cards.- Rust isn’t totally guaranteed safe since folks can and do use unsafe code.- Exact same situation in Swift- Go has escape hatches like it you race, but not only.So most “safe” things are really “safe enough” for some definition of “enough”.replyAlotOfReading 1 hour ago
| root | parent | next [–]
The language standard assumes that everyone collectively agrees to standard semantics implying certain things. If users don't follow the rules and write something without semantics (undefined behavior), the entire program is meaningless as opposed to just the bit around the violation. You know this, so I emphasize it here because it's entirely incompatible with the view that "good enough" is a meaningful concept to discuss from the PoV of the standard.Rust does a pretty good job formalizing what the safety guarantees are and when you can assume them. Other languages don't, but they also don't support safety concepts that C++ nominally does like safety critical systems. "Good enough" can be perfectly fine for a web service like Go while being grossly inadequate for HPC or safety critical.replysteveklabnik 1 hour ago
| root | parent | prev | next [–]
You’re misunderstanding what I’m saying. Safe Rust guarantees memory safety. Profiles do not. This is regardless of the ability of the unchecked versions, on both sides, to introduce issues.Profiles do not, even for code that is 100% using profiles, guarantee safety.replypizlonator 1 hour ago
| root | parent | next [–]
The kind of "safe Rust" where you never use `unsafe` and never call into a C library is theoretical. None of the major ports of software to Rust achieve that.So, no matter what safe language we talk about, "safety" always has its caveats.Can you be specific about what missing safety feature of profiles leads you to be so negative about them?replysteveklabnik 1 hour ago
| root | parent | next [–]
No, I am saying that safe rust says “if unsafe is correct, safe rust means memory safety.” Profiles does not even reach that bar, it says “code under profiles is safer.”It’s not about specifics, it’s about the stated goals of profiles. They do not claim to prove memory safety even with all of them turned on.replyAlotOfReading 3 hours ago
| root | parent | prev | next [–]
There'd be less opposition if profiles worked that way. The real goal is to define a subset that excludes 95% of the unsafe stuff, as opposed to providing hard guarantees.replycoffeeaddict1 3 hours ago
| root | parent | prev | next [–]
> And you could force all lifetime operations to use C++ stdlib refcounting primitives, and then have lifetime safety in a Swift-like way (i.e. eager refcounting everywhere)That's going to be a non-starter for 99% of serious C++ projects there. The performance hit is going to be way too large.For bounds checking, sure I think the performance penalty is so small that it can be done.replygmueckl 1 hour ago
| root | parent | next [–]
You have to realize that the number of locations in code where reference counter adjustment is actually meaningful is rather small and there are simple rules to keep the excess thrash from reference counting pointer wrappers to a minimum. The main one, as mentioned in the talk the sibling comment called out, is that it is OK to pass a raw pointer or reference to a function while holding on to a reference count for as long as that other function runs (and doesn't leak the pointer through a side effect). This rule catches a lot of pointless counter arithmetic through excessive pointer wrapper copying.replypizlonator 2 hours ago
| root | parent | prev | next [–]
That would have been my first guess but WebKit's experience doing exactly this is the opposite.See https://www.youtube.com/watch?v=RLw13wLM5KoNote that they also allowed other kinds of pointers so long as their use could be statically verified using very simple rules.replyjcranmer 2 hours ago
| parent | prev | next [–]
C and C++ are fundamentally memory-unsafe languages. That doesn't make them bad languages, but it is a reality that you have to face when you work with them. And one of the things we've learned is that building safe abstractions, while not a complete solution, does quite a long way.And then CISA suggested that "maybe we should stop using memory-unsafe languages." And this has some of the C++ committee utterly terrified; they need something that lets them tell the government that C++, today, is memory-safe. That thing is C++ profiles. It's not about actually making C++ memory-safe, it's about being able to check the box that C++ is memory-safe, and this is so important it needs to be voted into the standards yesterday and why are you guys saying mean things about C++ profiles...C++ profiles is a magic solution to the problem. As one committee member noted, there's not enough description of profiles yet to even figure out if it can be implemented or not. Instead, it's just a vague, well, compile with -fsanitize=address, compile with fortify-source, use hardened malloc, that makes my code memory-safe, right? And for as long as profiles remains a magic solution to check a box, it will remain vaporware in practice.One of the real risks I see in the C++ committee is that they seem to want to drive all of the implementers out of the room.replyAnimats 3 hours ago
| parent | prev | next [–]
Regardless of the technology the big thing Rust has that C++ does not is safety culture, and that's dominant here.True. So many proposals have gone by over the years. Here's one of mine from 2001.[1] Bad idea.
The layers of cruft in C++ have become so deep that it's a career just to understand them.DARPA has something called the TRACTOR program, "Translate All C to Rust". It's been underway for a year, and they have a consortium of universities working on it. Not much, if anything, has come out.
Disappointing.Rust is probably too hard. I write 100% safe Rust, and there are times when I hit an ownership structure wall and have to spend several days re-planning. So far I've always succeeded without using "unsafe" or indices, but it drags down productivity.Although object-oriented programming is out of fashion, classes with inheritance are useful.
It's really hard to do something comparable in Rust. Traits are not that helpful for this.Go is a good compromise. Safety at a minor cost in performance. Go is good enough for web back end stuff. Go has both GC and "green threads". This automates the problems that wear people down in C++ and Rust.[1] https://www.animats.com/papers/languages/cppstrictpointers.h...replyvlovich123 2 hours ago
| root | parent | next [–]
> So far I've always succeeded without using "unsafe" or indices, but it drags down productivity.I really don’t understand this perspective. The whole philosophy of Rust is one where you document why “unsafe” is safe. It is not and never has been a goal to make everything safe because that is an impossible goal to merge with high performance systems language because hardware itself is unsafe. It’s why the unsafe keyword exists. If that wasn’t the goal, unsafe wouldn’t.replyusefulcat 35 minutes ago
| root | parent | next [–]
If unsafe is not used, then no one has to determine whether the unsafe parts are actually safe.replyzozbot234 56 minutes ago
| root | parent | prev | next [–]
> So far I've always succeeded without using "unsafe" or indices, but it drags down productivity.There is a common perception that Rust is less productive than competing languages, but empirical research by Google and others has found this to be wrong.
Rust just shifts the effort earlier in the development phase, where the costs are often orders of magnitude lower.
You may spend a few hours struggling with the borrow checker, but that saves you countless days of debugging highly non-trivial defects, especially in a larger codebase.> Although object-oriented programming is out of fashion, classes with inheritance are useful. It's really hard to do something comparable in Rust. Traits are not that helpful for this.FWIW, "classes with inheritance" in Rust can be very elegantly modeled with generic typestate.
(Traits are used as part of this pattern, but are not the full story.) It might look clunky at first glance, but it accurately reflects the underlying semantics.replycass0wary 1 hour ago
| root | parent | prev | next [–]
TRACTOR is currently proceeding. The program is structured in phases. Each phase will present the participants with increasingly difficult challenges to translate. At the end of each phase the participants will be tested and the results of these tests will be publicly announced. The first phase of TRACTOR began in June and will run for six months.replydebo_ 3 hours ago
| root | parent | prev | next [–]
I think there is room for an ML with a modern toolchain story that just omits Rust's borrow checker and does something more boring. Typescript and Rust have primed a large number of developers to be open to it.replyzozbot234 48 minutes ago
| root | parent | next [–]
Isn't ReasonML pretty much that language already? Although the most popular language in that broader niche is probably Golang.replythrowawaymaths 2 hours ago
| root | parent | prev | next [–]
this is kinda the opposite of what i think people really want.
they want an LLL with borrow checking without all of the abstractions and baggage you get in rust.replycleartext412 1 hour ago
| root | parent | prev | next [–]
Judging by this https://vt.social/@lina/113056457969145576 rewriting any even remotely complex project to rust will require making decisions (function signatures, ownership and so on) based on information that might not be present in the C code at all, like API conventions. Translator being able to decide on all these things automatically would probably be quite close to solving the halting problem.replyefuquen 4 hours ago
| parent | prev | next [–]
And I would say the deficiencies in Profiles and the fact Safe C++ was killed is the technical decisions reflecting the culture problem.replyLorenDB 6 hours ago
| prev | next [–]
The title has potential to be a bit misleading, because as the article says, while Sean Baxter's proposal is not being continued, the committee is working on the Profiles proposal, which still will enable some level of safety. So C++ is still working towards safety, just not the Safe C++ safety.replyloeg 6 hours ago
| parent | next [–]
Seems clear enough to me.
The "Safe C++" proposal is not being continued.
Profiles is not what was proposed in "Safe C++."replyTinkersW 5 hours ago
| parent | prev | next [–]
Hardware level safety will arrive first(see Apple support for Memory Integrity Enforcement ), not as fool proof as SafeC++/Rust but no need to change code...replyTimorousBestie 6 hours ago
| parent | prev | next [–]
C++ is working towards safety with the same enthusiasm with which I tackle AI-generated merge requests.replycoffeeaddict1 6 hours ago
| parent | prev | next [–]
The safety story with Profiles is rather basic (almost laughable honestly) and hardly any improvement over what was already achievable with compiler flags and clang-tidy.replyusamoi 1 hour ago
| prev | next [–]
They are not rejecting Safe C++; they are rejecting memory safety. Majority of them believes that memory safety is just hype, and minority of them knows it's a problem, but doesn't want to restrict themselves about coding. If code runs, it is fine. If it does not, coder running is fine too.replysteveklabnik 1 hour ago
| parent | next [–]
The principles document that was accepted feels very targeted at Safe C++ specifically. It’s fair to say they rejected it.replytiberius_p 5 hours ago
| prev | next [–]
I'm not up to date with the latest developments in C++ but would't it be straightforward to do something like "#pragma pointer_safety strong" which would force the compiler to only accept the use of smart pointers or something along those lines. Was anything like this proposed so far?replyfavorited 5 hours ago
| parent | next [–]
You might be interested in this talk[0] by a WebKit engineer on how they're implementing similar approaches using libTooling and their own smart pointer types.For example, their tooling prevents code like this:
if (m_weakMember) { m_weakMember->doThing(); }
from compiling, forcing you to explicitly create an owning local reference, like so:
if (RefPtr strongLocal = m_weakMember.get()) { strongLocal->doThing(); }
unless it's a trivial inlined function, like a simple getter.[0]https://www.youtube.com/watch?v=RLw13wLM5Koreplypizlonator 3 hours ago
| root | parent | next [–]
I was going to link to this.My interpretation of Geoff's presentation is that some version of profiles might work, at least in the sense of making it possible to write C++ code that is substantially safer than what we have today.replytialaramex 51 minutes ago
| root | parent | next [–]
Geoff's stuff is mostly about heuristics. For his purpose that makes sense. If Apple are spending say $1Bn on security problems and Geoff spends $1M cutting such problems by 90% that's money well spent. The current direction of profiles is big on heuristics. Easy quick wins to maybe get C++ under the "Radioactively unsafe" radar even if it can't pass for safe.The most hopeful thing I saw in Geoff's talk was cultural. It sounds like Geoff's team wanted to get to safer code. Things went faster than expected, people landed "me too" unsolicited patches, that sort of thing. Of course this is self-reported, but assuming Geoff wasn't showing us a very flattering portrait of a grim reality, which I can't see any incentive for, this team sounds like while they'd get value from Rust they're delivering many of the same security benefits in C++ anyway.Bureaucrats don't like culture because it's hard to measure. "Make sure you hire programmers with a good culture" is hard to chart. You're probably going to end up running some awful quiz your team hates "Answer D, A, B, B, E, B to get 100%". Whereas "Use Rust not C++" is measurable, team A has 93% of code in Rust, but team B scored 94.5% so that's more Rust, they win.replypizlonator 2 minutes ago
| root | parent | next [–]
> Geoff's stuff is mostly about heuristics.That's not true at all.- The bounds safety part of it prevents those C operations that Fil-C or something like it would dynamically check. You can to use hardened API instead.- The cast safety part of it prevents C casts except if they're obviously safe.- The lifetime safety part of it forces you to use WebKit's smart pointers except when you have an overlooking root.Those are type safety rules. It's disingenuous to call them heuristics.It is true, however, that Geoff's rules don't go to 100% because:- There are nasty corners of C that aren't covered by any of those rules.- WebKit still has <10% ish code that isn't opted into those rules.- WebKit has JITs.randomNumber7 4 hours ago
| parent | prev | next [–]
The problem with this would probably be that you usually have to use some libraries with C APIs and regular pointers.You could compile your program with address sanitizer then it at least crashes in a defined way at runtime when memory corruption would happen. TCC (tiny C compiler initially written by fabrice bellard) also has such a feature I think.This of course makes it significantly slower.replyrecursivecaveat 5 hours ago
| parent | prev | next [–]
I don't think that really accomplishes anything. If you interpret it broadly enough to meaningfully improve safety you have to ban so much stuff that no codebase will ever turn it on. It's a pretty straightforward locally-verifiable property as well, so people who really want it don't need a pragma to enforce it.replyBoxFour 4 hours ago
| parent | prev | next [–]
> pragma pointer_safety strong" which would force the compiler to only accept the use of smart pointersYou’d possibly just be trading one problem for another though - ask anyone who’s had to debug a shared ownership issue.replyquotemstr 5 hours ago
| parent | prev | next [–]
That's what the "Profiles" feature is. The problem is that any nontrivial real world program in a non-GC language needs non-owning reference types to perform well, and you can't express the rules for safe use of non-owning references without augmenting the language. People have tried. You need something more sophisticated than using smart pointers for everything. In the limit, smart pointers for everything is just called "Python".What infuriates me about the C++ safety situation is that C++ is by and large a better, more expressive language than Rust is, particularly with respect to compile time type level metaprogramming. And I am being walked hands handcuffed behind my back, alongside everyone else, into the Rust world with its comparatively anemic proc macro shit because the C++ committee can't be bothered to care about memory safety.Because of the C++ standards committee's misfeasance, I'm going to have to live in a world where I don't get to use some of my favorite programming techniques.replyYoric 5 hours ago
| root | parent | next [–]
> In the limit, smart pointers for everything is just called "Python".To be more precise, it's old Python. Recent versions of Python use a gc.> And I am being walked hands handcuffed behind my back, alongside everyone else, into the Rust world with its comparatively anemic proc macro shit because the C++ committee can't be bothered to care about memory safety.Out of curiosity (as someone working on static analysis), what properties would you like your compiler to check?replyquotemstr 5 hours ago
| root | parent | next [–]
I've been thinking for a while now about using dependant typing to enforce good numerics in numerics kernels. Wouldn't it be nice if we could propagate value bounds and make catastrophic cancellation a type error?Have you worked much with SAL and MIDL from Microsoft? Using SAL (an aesthetically hideous but conceptually beautiful macro based gradual typing system for C and C++) overlay guarantees about not only reference safety but also sign comparison restriction, maximum buffer sizes, and so on.replyzevets 5 hours ago
| root | parent | next [–]
Please do this.But first: we need to take step-zero and introduce a type "r64": a "f64" that is not nan/inf.Rust has its uint-thats-not-zero - why not the same for floating point numbers??reply1718627440 4 hours ago
| root | parent | next [–]
> Rust has its uint-thats-not-zeroWhy do we need to single out a specific value.
It would be way better if we also could use uint-without-5-and-42.
What I would wish for is type attributes that really belong to the type.
typedef unsigned int __attribute__ ((constraint (X != 5 && X != 42))) my_type;replysteveklabnik 3 hours ago
| root | parent | next [–]
Those are the unstable attributes that your sibling is talking about.reply1718627440 3 hours ago
| root | parent | next [–]
Yeah of course I can put what I want in my toy compiler.
My statement was about standard C.
I think that's what Contracts really are and hope this will be included in C.replysteveklabnik 2 hours ago
| root | parent | next [–]
Oh sure, I wouldn’t call rustc a “toy compiler” but yeah, they’d be cool in C as well.replytialaramex 4 hours ago
| root | parent | prev | next [–]
You can write your "r64" type today. You would need a perma-unstable compiler-only feature to give your type a huge niche where the missing bit patterns would go, but otherwise there's no problem that I can see, so if you don't care about the niche it's just another crate - there is something similar called noisy_floatreplyzevets 3 hours ago
| root | parent | next [–]
I can do it, and I do similar such things in C++ - but the biggest benefit of "safe defaults" is the standardization of such behaviors, and the resultant expectations/ecosystem.replyquotemstr 6 hours ago
| prev | next [–]
Okay, so treat the C++ standards committee the same way the HTML5 people treated W3C. If they insist on making themselves irrelevant, let them.Profiles cannot achieve the same level of safety as Rust and it's obvious to anyone who breathes. Profiles just delete stuff from the language. Without lifetimes reified as types you can't express semantics with precision enough to check them. The moment string_view appears, you're horked.Okay, so you ban all uncounted reference types too. Now what you're left with isn't shit Rust but instead shit Swift, one that combines the performance of a turtle with the ergonomics of a porcupine.There's no value in making things a little bit safer here and there. The purpose of a type system is to embed proofs about invariants. If your system doesn't actually prove the the invariant, you can't rely on it and you've made is a shitty linter.Continue the safe C++ work outside the context of the C++ standards committee. Its members, if you ignore their words and focus on the behaviors, would rather see the language become irrelevant than change decades old practices. Typical iron law of bureaucracy territory.replyint_19h 5 hours ago
| parent | next [–]
The reason why WHATWG was able to take over HTML like that is because all the people & companies that were actually making the browsers were onboard.With C++, my impression is that most implementers simply aren't interested. And, conversely, most people who might be interested enough to roll a new implementation have already moved to Rust and make better use of their time improving that.replyfavorited 5 hours ago
| root | parent | next [–]
The browser companies weren't just onboard with WHATWG – they literally are WHATWG. The WHATWG steering committee is Apple, Google, Microsoft, and Mozilla.replyquotemstr 5 hours ago
| root | parent | prev | next [–]
You're right, but dammit, I wish you weren't. A world in which we can evolve existing large C++ codebases gradually towards safety instead of having to RRiR is a better world.There are lots of cool innovations C++ made that will just disappear from the Earth, forever, if C++ can't be made memory safe in the same sense Rust is. I mean, Rust doesn't even support template specialization.I don't think it's too late for someone to fork both C++ and Clang and make something that's actually a good synthesis of the old and the new.But yeah, the most likely future is one on which C++ goes the way of Fortran (which still gets regular updates, however irrelevant) and the energy goes into Rust. But I like to rage, rage, against the dying of the type based metaprogramming.replyBoxFour 4 hours ago
| root | parent | next [–]
> I don't think it's too late for someone to fork both C++ and Clang and make something that's actually a good synthesis of the old and the new.People have tried variants of this already: Carbon, for example. I don’t think anyone outside of Google uses it, though, and even within Google I suspect it’s dwarfed by regular C++.I don’t think C++ will become irrelevant for a long time. Recent standards have added some cool new features (like std::expected), and personally I feel like the language is better than ever (a biased opinion obviously).Memory management is still a huge elephant in the room, but I don’t think it’s becoming irrelevant.replytialaramex 4 hours ago
| root | parent | prev | next [–]
Well like you said, Fortran didn't actually go anywhere. Fortan 77 is a terrible programming language, but you can't seriously claim it "disappeared from the Earth".Not that long ago tsoding was like "I should learn Fortran" and wrote a bunch of Fortran. Obviously from his perspective some things about Fortran are awful because it's very old, but it wasn't somehow impossible to do.There are a few really amazing things which have been achieved in C++ like fmt, a compile time checked, userspace library for arbitrarily formatting variadic generic parameters. That's like man on the moon stuff, genuinely impressive. Mostly though C++ is a garbage fire and so while it's important to learn about it and from it we should not keep doing that.replyYoric 4 hours ago
| root | parent | next [–]
> There are a few really amazing things which have been achieved in C++ like fmt, a compile time checked, userspace library for arbitrarily formatting variadic generic parameters.Anecdotal, but that's hardly unique to C++. So even if C++ were to disappear overnight (which we all agree won't happen), this wouldn't be a burning-library-of-Alexandria moment.replytialaramex 4 hours ago
| root | parent | next [–]
Well. What other examples of this feat are you thinking of?To me the things which come to mind are either compiler magic (e.g. C printf) or they rely on RTTI (e.g. Odin and similar C-like languages) and neither of those is what fmt does, they're "cheating" in some sense that actually matters.replypklausler 4 hours ago
| root | parent | prev | next [–]
Judging Fortran by looking at Fortran 77 is preposterously uninformative.replyYoric 4 hours ago
| root | parent | prev | next [–]
FWIW, Rust doesn't have specialization yet because they're really hard to get right without introducing new undefined behaviors.This doesn't mean that it's not possible to achieve a safe subset of C++ that supports template specialization, but it suggests that we aren't going to see it any time soon.replyfooker 3 hours ago
| root | parent | prev | next [–]
> fork both C++ and ClangGreat! What are you waiting for?If you try to answer that question, you'll also find why other similar projects are not finding much traction yet.replysafercplusplus 3 hours ago
| parent | prev | next [–]
> Profiles cannot achieve the same level of safety as RustSo the claim is that the scpptool approach[1] can, while remaining closer to traditional C++, and not requiring the introduction of new language elements. Since the scpptool-enforced safe subset of C++ is an actual subset of C++, conforming code continues to build with your existing compiler. It just uses an additional static analyzer to check conformance.For the 90% or whatever of C++ code that is not actually performance sensitive, the associated SaferCPlusPlus library provides drop-in and "one-to-one" safe replacements for unsafe C++ elements (like standard library containers and raw pointers). (For example, if you're worried about potentially invalid vector iterators, you can just replace your std::vector<>s with mse::mstd::vector<>s.) With these elements, most of the safety is enforced in the type system and not reliant on the static analyzer.Conforming implementations of performance-sensitive code would be more restricted and more reliant on the static analyzer for safety enforcement. And sometimes requires the use of library elements, like "borrowing objects", which may not have analogies in traditional C++. But overall, even high-performance conforming code remains very recognizable C++.The claim is that the scpptool approach is a straightforward path to full memory (and data race) safety for C++, and the one that requires the least code migration effort. (And again, as an actual subset of existing C++, not technically dependent on standard committees or compiler vendors for its implementation or deployment.)[1]: https://github.com/duneroadrunner/scpptool/blob/master/appro...replystrus 6 hours ago
| prev | next [–]
I don’t think anyone is surprised.replyflykespice 3 hours ago
| prev [–]
C++ will never be safe as long as its C root persists, it doesn't matters how much freatures you add on top of C++ to make writing safe programs more convenient.You need to take off the "inherently unsafe" C root from C++, but it wouldn't be called C++ anymore by that point.replywinrid 2 hours ago
| parent [–]
C+++ :)replyImTotallyVegan 1 hour ago
| root | parent [–]
C+-reply
Guidelines | FAQ | Lists | API | Security | Legal | Apply to YC | Contact
Search: